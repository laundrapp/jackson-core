//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Salton/Documents/Projects/jackson-core/src/main/java/com/fasterxml/jackson/core/sym/CharsToNameCanonicalizer.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer")
#ifdef RESTRICT_ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer
#define INCLUDE_ALL_ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer 0
#else
#define INCLUDE_ALL_ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer 1
#endif
#undef RESTRICT_ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_) && (INCLUDE_ALL_ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer || defined(INCLUDE_ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer))
#define ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_

@class IOSCharArray;

/*!
 @brief This class is a kind of specialized type-safe Map, from char array to
  String value.Specialization means that in addition to type-safety
  and specific access patterns (key char array, Value optionally interned
  String; values added on access if necessary), and that instances are
  meant to be used concurrently, but by using well-defined mechanisms
  to obtain such concurrently usable instances.
 Main use for the class
  is to store symbol table information for things like compilers and
  parsers; especially when number of symbols (keywords) is limited.
 <p>
  For optimal performance, usage pattern should be one where matches
  should be very common (especially after "warm-up"), and as with most hash-based
  maps/sets, that hash codes are uniformly distributed. Also, collisions
  are slightly more expensive than with HashMap or HashSet, since hash codes
  are not used in resolving collisions; that is, equals() comparison is
  done with all symbols in same bucket index.<br>
  Finally, rehashing is also more expensive, as hash codes are not
  stored; rehashing requires all entries' hash codes to be recalculated.
  Reason for not storing hash codes is reduced memory usage, hoping
  for better memory locality.
 <p>
  Usual usage pattern is to create a single "master" instance, and either
  use that instance in sequential fashion, or to create derived "child"
  instances, which after use, are asked to return possible symbol additions
  to master instance. In either case benefit is that symbol table gets
  initialized so that further uses are more efficient, as eventually all
  symbols needed will already be in symbol table. At that point no more
  Symbol String allocations are needed, nor changes to symbol table itself.
 <p>
  Note that while individual SymbolTable instances are NOT thread-safe
  (much like generic collection classes), concurrently used "child"
  instances can be freely used without synchronization. However, using
  master table concurrently with child instances can only be done if
  access to master instance is read-only (i.e. no modifications done).
 */
@interface ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer : NSObject

#pragma mark Public

/*!
 @brief Helper method that takes in a "raw" hash value, shuffles it as necessary,
  and truncates to be used as the index.
 */
- (jint)_hashToIndexWithInt:(jint)rawHash;

/*!
 @brief Method for checking number of primary hash buckets this symbol
  table uses.
 @since 2.1
 */
- (jint)bucketCount;

/*!
 @brief Implementation of a hashing method for variable length
  Strings.Most of the time intention is that this calculation
  is done by caller during parsing, not here; however, sometimes
  it needs to be done for parsed "String" too.
 @param len Length of String; has to be at least 1 (caller guarantees    this pre-condition)
 */
- (jint)calcHashWithCharArray:(IOSCharArray *)buffer
                      withInt:(jint)start
                      withInt:(jint)len;

- (jint)calcHashWithNSString:(NSString *)key;

/*!
 @brief Method mostly needed by unit tests; calculates number of
  entries that are in collision list.Value can be at most
  (<code>size</code> - 1), but should usually be much lower, ideally 0.
 @since 2.1
 */
- (jint)collisionCount;

/*!
 @brief Method called to create root canonicalizer for a <code>com.fasterxml.jackson.core.json.JsonFactory</code>
  instance.Root instance is never used directly; its main use is for
  storing and sharing underlying symbol arrays as needed.
 */
+ (ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer *)createRoot;

- (NSString *)findSymbolWithCharArray:(IOSCharArray *)buffer
                              withInt:(jint)start
                              withInt:(jint)len
                              withInt:(jint)h;

- (jint)hashSeed;

/*!
 @brief "Factory" method; will create a new child instance of this symbol
  table.It will be a copy-on-write instance, ie. it will only use
  read-only copy of parent's data, but when changes are needed, a
  copy will be created.
 <p>
  Note: while this method is synchronized, it is generally not
  safe to both use makeChild/mergeChild, AND to use instance
  actively. Instead, a separate 'root' instance should be used
  on which only makeChild/mergeChild are called, but instance itself
  is not used as a symbol table.
 */
- (ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer *)makeChildWithInt:(jint)flags;

/*!
 @brief Method mostly needed by unit tests; calculates length of the
  longest collision chain.This should typically be a low number,
  but may be up to <code>size</code> - 1 in the pathological case
 @since 2.1
 */
- (jint)maxCollisionLength;

- (jboolean)maybeDirty;

/*!
 @brief Method called by the using code to indicate it is done with this instance.
 This lets instance merge accumulated changes into parent (if need be),
  safely and efficiently, and without calling code having to know about parent
  information.
 */
- (void)release__;

- (jint)size;

#pragma mark Protected

+ (ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer *)createRootWithInt:(jint)seed;

- (void)reportTooManyCollisionsWithInt:(jint)maxLen;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer)

inline jint ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_get_HASH_MULT(void);
#define ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_HASH_MULT 33
J2OBJC_STATIC_FIELD_CONSTANT(ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer, HASH_MULT, jint)

/*!
 @brief Let's only share reasonably sized symbol tables.Max size set to 3/4 of 16k;
  this corresponds to 64k main hash index.
 This should allow for enough distinct
  names for almost any case.
 */
inline jint ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_get_MAX_ENTRIES_FOR_REUSE(void);
#define ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_MAX_ENTRIES_FOR_REUSE 12000
J2OBJC_STATIC_FIELD_CONSTANT(ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer, MAX_ENTRIES_FOR_REUSE, jint)

/*!
 @brief Also: to thwart attacks based on hash collisions (which may or may not
  be cheap to calculate), we will need to detect "too long"
  collision chains.Let's start with static value of 255 entries
  for the longest legal chain.
 <p>
  Note: longest chain we have been able to produce without malicious
  intent has been 38 (with "com.fasterxml.jackson.core.main.TestWithTonsaSymbols");
  our setting should be reasonable here.
 <p>
  Also note that value was lowered from 255 (2.3 and earlier) to 100 for 2.4
 @since 2.1
 */
inline jint ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_get_MAX_COLL_CHAIN_LENGTH(void);
#define ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_MAX_COLL_CHAIN_LENGTH 100
J2OBJC_STATIC_FIELD_CONSTANT(ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer, MAX_COLL_CHAIN_LENGTH, jint)

FOUNDATION_EXPORT ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer *ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_createRoot(void);

FOUNDATION_EXPORT ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer *ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_createRootWithInt_(jint seed);

J2OBJC_TYPE_LITERAL_HEADER(ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer)

#endif

#if !defined (ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket_) && (INCLUDE_ALL_ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer || defined(INCLUDE_ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket))
#define ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket_

@class IOSCharArray;

/*!
 @brief This class is a symbol table entry.Each entry acts as a node
  in a linked list.
 */
@interface ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket : NSObject {
 @public
  NSString *symbol_;
  ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket *next_;
  jint length_;
}

#pragma mark Public

- (instancetype __nonnull)initWithNSString:(NSString *)s
withComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket:(ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket *)n;

- (NSString *)hasWithCharArray:(IOSCharArray *)buf
                       withInt:(jint)start
                       withInt:(jint)len;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket)

J2OBJC_FIELD_SETTER(ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket, symbol_, NSString *)
J2OBJC_FIELD_SETTER(ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket, next_, ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket *)

FOUNDATION_EXPORT void ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket_initWithNSString_withComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket_(ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket *self, NSString *s, ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket *n);

FOUNDATION_EXPORT ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket *new_ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket_initWithNSString_withComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket_(NSString *s, ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket *n) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket *create_ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket_initWithNSString_withComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket_(NSString *s, ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket *n);

J2OBJC_TYPE_LITERAL_HEADER(ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer_Bucket)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_ComFasterxmlJacksonCoreSymCharsToNameCanonicalizer")
