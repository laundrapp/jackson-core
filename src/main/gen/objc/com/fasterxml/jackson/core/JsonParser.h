//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Salton/Documents/Projects/jackson-core/src/main/java/com/fasterxml/jackson/core/JsonParser.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_ComFasterxmlJacksonCoreJsonParser")
#ifdef RESTRICT_ComFasterxmlJacksonCoreJsonParser
#define INCLUDE_ALL_ComFasterxmlJacksonCoreJsonParser 0
#else
#define INCLUDE_ALL_ComFasterxmlJacksonCoreJsonParser 1
#endif
#undef RESTRICT_ComFasterxmlJacksonCoreJsonParser

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (ComFasterxmlJacksonCoreJsonParser_) && (INCLUDE_ALL_ComFasterxmlJacksonCoreJsonParser || defined(INCLUDE_ComFasterxmlJacksonCoreJsonParser))
#define ComFasterxmlJacksonCoreJsonParser_

#define RESTRICT_JavaIoCloseable 1
#define INCLUDE_JavaIoCloseable 1
#include "java/io/Closeable.h"

#define RESTRICT_ComFasterxmlJacksonCoreVersioned 1
#define INCLUDE_ComFasterxmlJacksonCoreVersioned 1
#include "com/fasterxml/jackson/core/Versioned.h"

@class ComFasterxmlJacksonCoreBase64Variant;
@class ComFasterxmlJacksonCoreJsonLocation;
@class ComFasterxmlJacksonCoreJsonParseException;
@class ComFasterxmlJacksonCoreJsonParser_Feature;
@class ComFasterxmlJacksonCoreJsonParser_NumberType;
@class ComFasterxmlJacksonCoreJsonStreamContext;
@class ComFasterxmlJacksonCoreJsonToken;
@class ComFasterxmlJacksonCoreObjectCodec;
@class ComFasterxmlJacksonCoreTypeTypeReference;
@class ComFasterxmlJacksonCoreUtilRequestPayload;
@class ComFasterxmlJacksonCoreVersion;
@class IOSByteArray;
@class IOSCharArray;
@class IOSClass;
@class JavaIoOutputStream;
@class JavaIoWriter;
@class JavaLangBoolean;
@class JavaMathBigDecimal;
@class JavaMathBigInteger;
@protocol ComFasterxmlJacksonCoreAsyncNonBlockingInputFeeder;
@protocol ComFasterxmlJacksonCoreFormatSchema;
@protocol ComFasterxmlJacksonCoreSerializableString;
@protocol ComFasterxmlJacksonCoreTreeNode;
@protocol JavaUtilIterator;

/*!
 @brief Base class that defines public API for reading JSON content.
 Instances are created using factory methods of
  a <code>JsonFactory</code> instance.
 @author Tatu Saloranta
 */
@interface ComFasterxmlJacksonCoreJsonParser : NSObject < JavaIoCloseable, ComFasterxmlJacksonCoreVersioned > {
 @public
  /*!
   @brief Bit flag composed of bits that indicate which 
 <code>com.fasterxml.jackson.core.JsonParser.Feature</code>s
  are enabled.
   */
  jint _features_;
  /*!
   @brief Optional container that holds the request payload which will be displayed on JSON parsing error.
   @since 2.8
   */
  ComFasterxmlJacksonCoreUtilRequestPayload *_requestPayload_;
}

#pragma mark Public

/*!
 @brief Method that can be called to determine if this parser instance
  uses non-blocking ("asynchronous") input access for decoding or not.
 Access mode is determined by earlier calls via <code>JsonFactory</code>;
  it may not be changed after construction.
 <p>
  If non-blocking decoding is u (@@code true}, it is possible to call 
 <code>getNonBlockingInputFeeder()</code> to obtain object to use
  for feeding input; otherwise (<code>false</code> returned)
  input is read by blocking
 @since 2.9
 */
- (jboolean)canParseAsync;

/*!
 @brief Introspection method that may be called to see if the underlying
  data format supports some kind of Object Ids natively (many do not;
  for example, JSON doesn't).
 <p>
  Default implementation returns true; overridden by data formats
  that do support native Object Ids. Caller is expected to either
  use a non-native notation (explicit property or such), or fail,
  in case it can not use native object ids.
 @since 2.3
 */
- (jboolean)canReadObjectId;

/*!
 @brief Introspection method that may be called to see if the underlying
  data format supports some kind of Type Ids natively (many do not;
  for example, JSON doesn't).
 <p>
  Default implementation returns true; overridden by data formats
  that do support native Type Ids. Caller is expected to either
  use a non-native notation (explicit property or such), or fail,
  in case it can not use native type ids.
 @since 2.3
 */
- (jboolean)canReadTypeId;

/*!
 @brief Method that can be used to verify that given schema can be used with
  this parser (using <code>setSchema</code>).
 @param schema Schema to check
 @return True if this parser can use given schema; false if not
 */
- (jboolean)canUseSchemaWithComFasterxmlJacksonCoreFormatSchema:(id<ComFasterxmlJacksonCoreFormatSchema>)schema;

/*!
 @brief Method called to "consume" the current token by effectively
  removing it so that <code>hasCurrentToken</code> returns false, and 
 <code>getCurrentToken</code> null).
 Cleared token value can still be accessed by calling 
 <code>getLastClearedToken</code> (if absolutely needed), but
  usually isn't.
 <p>
  Method was added to be used by the optional data binder, since
  it has to be able to consume last token used for binding (so that
  it will not be used again).
 */
- (void)clearCurrentToken;

/*!
 @brief Closes the parser so that no further iteration or data access
  can be made; will also close the underlying input source
  if parser either <b>owns</b> the input source, or feature 
 <code>Feature.AUTO_CLOSE_SOURCE</code> is enabled.
 Whether parser owns the input source depends on factory
  method that was used to construct instance (so check 
 <code>com.fasterxml.jackson.core.JsonFactory</code> for details,
  but the general
  idea is that if caller passes in closable resource (such
  as <code>InputStream</code> or <code>Reader</code>) parser does NOT
  own the source; but if it passes a reference (such as 
 <code>java.io.File</code> or <code>java.net.URL</code> and creates
  stream or reader it does own them.
 */
- (void)close;

/*!
 @brief Method for enabling or disabling specified feature
  (check <code>Feature</code> for list of features)
 */
- (ComFasterxmlJacksonCoreJsonParser *)configureWithComFasterxmlJacksonCoreJsonParser_Feature:(ComFasterxmlJacksonCoreJsonParser_Feature *)f
                                                                                  withBoolean:(jboolean)state;

/*!
 @brief Accessor to find which token parser currently points to, if any;
  null will be returned if none.
 If return value is non-null, data associated with the token
  is available via other accessor methods.
 @return Type of the token this parser currently points to,
    if any: null before any tokens have been read, and
    after end-of-input has been encountered, as well as
    if the current token has been explicitly cleared.
 @since 2.8
 */
- (ComFasterxmlJacksonCoreJsonToken *)currentToken;

/*!
 @brief Method similar to <code>getCurrentToken()</code> but that returns an 
 <code>int</code> instead of <code>JsonToken</code> (enum value).
 <p>
  Use of int directly is typically more efficient on switch statements,
  so this method may be useful when building low-overhead codecs.
  Note, however, that effect may not be big enough to matter: make sure
  to profile performance before deciding to use this method.
 @since 2.8
 @return <code>int</code> matching one of constants from <code>JsonTokenId</code>.
 */
- (jint)currentTokenId;

/*!
 @brief Method for disabling specified  feature
  (check <code>Feature</code> for list of features)
 */
- (ComFasterxmlJacksonCoreJsonParser *)disableWithComFasterxmlJacksonCoreJsonParser_Feature:(ComFasterxmlJacksonCoreJsonParser_Feature *)f;

/*!
 @brief Method for enabling specified parser feature
  (check <code>Feature</code> for list of features)
 */
- (ComFasterxmlJacksonCoreJsonParser *)enableWithComFasterxmlJacksonCoreJsonParser_Feature:(ComFasterxmlJacksonCoreJsonParser_Feature *)f;

/*!
 @brief Method that may be used to force full handling of the current token
  so that even if lazy processing is enabled, the whole contents are
  read for possible retrieval.This is usually used to ensure that
  the token end location is available, as well as token contents
  (similar to what calling, say <code>getTextCharacters()</code>, would
  achieve).
 <p>
  Note that for many dataformat implementations this method
  will not do anything; this is the default implementation unless
  overridden by sub-classes.
 @since 2.8
 */
- (void)finishToken;

/*!
 @brief Numeric accessor that can be called when the current
  token is of type <code>JsonToken.VALUE_NUMBER_INT</code> and
  it can not be used as a Java long primitive type due to its
  magnitude.
 It can also be called for <code>JsonToken.VALUE_NUMBER_FLOAT</code>;
  if so, it is equivalent to calling <code>getDecimalValue</code>
  and then constructing a <code>BigInteger</code> from that value.
 */
- (JavaMathBigInteger *)getBigIntegerValue;

/*!
 @brief Convenience alternative to <code>getBinaryValue(Base64Variant)</code>
  that defaults to using 
 <code>Base64Variants.getDefaultVariant</code> as the default encoding.
 */
- (IOSByteArray *)getBinaryValue;

/*!
 @brief Method that can be used to read (and consume -- results
  may not be accessible using other methods after the call)
  base64-encoded binary data
  included in the current textual JSON value.
 It works similar to getting String value via <code>getText</code>
  and decoding result (except for decoding part),
  but should be significantly more performant.
 <p>
  Note that non-decoded textual contents of the current token
  are not guaranteed to be accessible after this method
  is called. Current implementation, for example, clears up
  textual content during decoding.
  Decoded binary content, however, will be retained until
  parser is advanced to the next event.
 @param bv Expected variant of base64 encoded    content (see 
 <code>Base64Variants</code>  for definitions    of "standard" variants).
 @return Decoded binary data
 */
- (IOSByteArray *)getBinaryValueWithComFasterxmlJacksonCoreBase64Variant:(ComFasterxmlJacksonCoreBase64Variant *)bv;

/*!
 @brief Convenience accessor that can be called when the current
  token is <code>JsonToken.VALUE_TRUE</code> or 
 <code>JsonToken.VALUE_FALSE</code>.
 <p>
  Note: if the token is not of above-mentioned boolean types,
  an integer, but its value falls
  outside of range of Java long, a <code>JsonParseException</code>
  may be thrown to indicate numeric overflow/underflow.
 */
- (jboolean)getBooleanValue;

/*!
 @brief Numeric accessor that can be called when the current
  token is of type <code>JsonToken.VALUE_NUMBER_INT</code> and
  it can be expressed as a value of Java byte primitive type.
 It can also be called for <code>JsonToken.VALUE_NUMBER_FLOAT</code>;
  if so, it is equivalent to calling <code>getDoubleValue</code>
  and then casting; except for possible overflow/underflow
  exception.
 <p>
  Note: if the resulting integer value falls outside range of
  Java byte, a <code>JsonParseException</code>
  will be thrown to indicate numeric overflow/underflow.
 */
- (jbyte)getByteValue;

/*!
 @brief Accessor for <code>ObjectCodec</code> associated with this
  parser, if any.Codec is used by <code>readValueAs(Class)</code>
  method (and its variants).
 */
- (ComFasterxmlJacksonCoreObjectCodec *)getCodec;

/*!
 @brief Method that returns location of the last processed character;
  usually for error reporting purposes.
 */
- (ComFasterxmlJacksonCoreJsonLocation *)getCurrentLocation;

/*!
 @brief Method that can be called to get the name associated with
  the current token: for <code>JsonToken.FIELD_NAME</code>s it will
  be the same as what <code>getText</code> returns;
  for field values it will be preceding field name;
  and for others (array values, root-level values) null.
 */
- (NSString *)getCurrentName;

/*!
 @brief Alias for <code>currentToken()</code>, will be deprecated in Jackson 2.9
 */
- (ComFasterxmlJacksonCoreJsonToken *)getCurrentToken;

/*!
 @brief Alias for <code>currentTokenId()</code>, will be deprecated in Jackson 2.9
 */
- (jint)getCurrentTokenId;

/*!
 @brief Helper method, usually equivalent to:
 <code>
    getParsingContext().getCurrentValue();
 </code>
 <p>
  Note that "current value" is NOT populated (or used) by Streaming parser;
  it is only used by higher-level data-binding functionality.
 The reason it is included here is that it can be stored and accessed hierarchically,
  and gets passed through data-binding.
 @since 2.5
 */
- (id)getCurrentValue;

/*!
 @brief Numeric accessor that can be called when the current
  token is of type <code>JsonToken.VALUE_NUMBER_FLOAT</code> or 
 <code>JsonToken.VALUE_NUMBER_INT</code>.No under/overflow exceptions
  are ever thrown.
 */
- (JavaMathBigDecimal *)getDecimalValue;

/*!
 @brief Numeric accessor that can be called when the current
  token is of type <code>JsonToken.VALUE_NUMBER_FLOAT</code> and
  it can be expressed as a Java double primitive type.
 It can also be called for <code>JsonToken.VALUE_NUMBER_INT</code>;
  if so, it is equivalent to calling <code>getLongValue</code>
  and then casting; except for possible overflow/underflow
  exception.
 <p>
  Note: if the value falls
  outside of range of Java double, a <code>JsonParseException</code>
  will be thrown to indicate numeric overflow/underflow.
 */
- (jdouble)getDoubleValue;

/*!
 @brief Accessor that can be called if (and only if) the current token
  is <code>JsonToken.VALUE_EMBEDDED_OBJECT</code>.For other token types,
  null is returned.
 <p>
  Note: only some specialized parser implementations support
  embedding of objects (usually ones that are facades on top
  of non-streaming sources, such as object trees). One exception
  is access to binary content (whether via base64 encoding or not)
  which typically is accessible using this method, as well as 
 <code>getBinaryValue()</code>.
 */
- (id)getEmbeddedObject;

/*!
 @brief Bulk access method for getting state of all standard <code>Feature</code>s.
 @return Bit mask that defines current states of all standard <code>Feature</code>s.
 @since 2.3
 */
- (jint)getFeatureMask;

/*!
 @brief Numeric accessor that can be called when the current
  token is of type <code>JsonToken.VALUE_NUMBER_FLOAT</code> and
  it can be expressed as a Java float primitive type.
 It can also be called for <code>JsonToken.VALUE_NUMBER_INT</code>;
  if so, it is equivalent to calling <code>getLongValue</code>
  and then casting; except for possible overflow/underflow
  exception.
 <p>
  Note: if the value falls
  outside of range of Java float, a <code>JsonParseException</code>
  will be thrown to indicate numeric overflow/underflow.
 */
- (jfloat)getFloatValue;

/*!
 @brief Bulk access method for getting state of all <code>FormatFeature</code>s, format-specific
  on/off configuration settings.
 @return Bit mask that defines current states of all standard <code>FormatFeature</code>s.
 @since 2.6
 */
- (jint)getFormatFeatures;

/*!
 @brief Method that can be used to get access to object that is used
  to access input being parsed; this is usually either 
 <code>InputStream</code> or <code>Reader</code>, depending on what
  parser was constructed with.
 Note that returned value may be null in some cases; including
  case where parser implementation does not want to exposed raw
  source to caller.
  In cases where input has been decorated, object returned here
  is the decorated version; this allows some level of interaction
  between users of parser and decorator object.
 <p>
  In general use of this accessor should be considered as
  "last effort", i.e. only used if no other mechanism is applicable.
 */
- (id)getInputSource;

/*!
 @brief Numeric accessor that can be called when the current
  token is of type <code>JsonToken.VALUE_NUMBER_INT</code> and
  it can be expressed as a value of Java int primitive type.
 It can also be called for <code>JsonToken.VALUE_NUMBER_FLOAT</code>;
  if so, it is equivalent to calling <code>getDoubleValue</code>
  and then casting; except for possible overflow/underflow
  exception.
 <p>
  Note: if the resulting integer value falls outside range of
  Java int, a <code>JsonParseException</code>
  may be thrown to indicate numeric overflow/underflow.
 */
- (jint)getIntValue;

/*!
 @brief Method that can be called to get the last token that was
  cleared using <code>clearCurrentToken</code>.This is not necessarily
  the latest token read.
 Will return null if no tokens have been cleared,
  or if parser has been closed.
 */
- (ComFasterxmlJacksonCoreJsonToken *)getLastClearedToken;

/*!
 @brief Numeric accessor that can be called when the current
  token is of type <code>JsonToken.VALUE_NUMBER_INT</code> and
  it can be expressed as a Java long primitive type.
 It can also be called for <code>JsonToken.VALUE_NUMBER_FLOAT</code>;
  if so, it is equivalent to calling <code>getDoubleValue</code>
  and then casting to int; except for possible overflow/underflow
  exception.
 <p>
  Note: if the token is an integer, but its value falls
  outside of range of Java long, a <code>JsonParseException</code>
  may be thrown to indicate numeric overflow/underflow.
 */
- (jlong)getLongValue;

/*!
 @brief Method that will either return a feeder instance (if parser uses
  non-blocking, aka asynchronous access); or <code>null</code> for
  parsers that use blocking I/O.
 @since 2.9
 */
- (id<ComFasterxmlJacksonCoreAsyncNonBlockingInputFeeder>)getNonBlockingInputFeeder;

/*!
 @brief If current token is of type  
 <code>JsonToken.VALUE_NUMBER_INT</code> or 
 <code>JsonToken.VALUE_NUMBER_FLOAT</code>, returns
  one of <code>NumberType</code> constants; otherwise returns null.
 */
- (ComFasterxmlJacksonCoreJsonParser_NumberType *)getNumberType;

/*!
 @brief Generic number value accessor method that will work for
  all kinds of numeric values.It will return the optimal
  (simplest/smallest possible) wrapper object that can
  express the numeric value just parsed.
 */
- (NSNumber *)getNumberValue;

/*!
 @brief Method that can be called to check whether current token
  (one that was just read) has an associated Object id, and if
  so, return it.
 Note that while typically caller should check with <code>canReadObjectId</code>
  first, it is not illegal to call this method even if that method returns
  true; but if so, it will return null. This may be used to simplify calling
  code.
 <p>
  Default implementation will simply return null.
 @since 2.3
 */
- (id)getObjectId;

/*!
 @brief Method that can be used to access current parsing context reader
  is in.There are 3 different types: root, array and object contexts,
  with slightly different available information.
 Contexts are
  hierarchically nested, and can be used for example for figuring
  out part of the input document that correspond to specific
  array or object (for highlighting purposes, or error reporting).
  Contexts can also be used for simple xpath-like matching of
  input, if so desired.
 */
- (ComFasterxmlJacksonCoreJsonStreamContext *)getParsingContext;

/*!
 @brief Method for accessing Schema that this parser uses, if any.
 Default implementation returns null.
 @since 2.1
 */
- (id<ComFasterxmlJacksonCoreFormatSchema>)getSchema;

/*!
 @brief Numeric accessor that can be called when the current
  token is of type <code>JsonToken.VALUE_NUMBER_INT</code> and
  it can be expressed as a value of Java short primitive type.
 It can also be called for <code>JsonToken.VALUE_NUMBER_FLOAT</code>;
  if so, it is equivalent to calling <code>getDoubleValue</code>
  and then casting; except for possible overflow/underflow
  exception.
 <p>
  Note: if the resulting integer value falls outside range of
  Java short, a <code>JsonParseException</code>
  will be thrown to indicate numeric overflow/underflow.
 */
- (jshort)getShortValue;

/*!
 @brief Method for accessing textual representation of the current token;
  if no current token (before first call to <code>nextToken</code>, or
  after encountering end-of-input), returns null.
 Method can be called for any token type.
 */
- (NSString *)getText;

/*!
 @brief Method to read the textual representation of the current token in chunks and 
  pass it to the given Writer.
 Conceptually same as calling:
 @code

   writer.write(parser.getText());
 
@endcode
  but should typically be more efficient as longer content does need to
  be combined into a single <code>String</code> to return, and write
  can occur directly from intermediate buffers Jackson uses.
 @return The number of characters written to the Writer
 @since 2.8
 */
- (jint)getTextWithJavaIoWriter:(JavaIoWriter *)writer;

/*!
 @brief Method similar to <code>getText</code>, but that will return
  underlying (unmodifiable) character array that contains
  textual value, instead of constructing a String object
  to contain this information.
 Note, however, that:
 <ul>
  <li>Textual contents are not guaranteed to start at
    index 0 (rather, call <code>getTextOffset</code>) to
    know the actual offset  
 </li>
  <li>Length of textual contents may be less than the
   length of returned buffer: call <code>getTextLength</code>
   for actual length of returned content.  
 </li>
  </ul>
 <p>
  Note that caller <b>MUST NOT</b> modify the returned
  character array in any way -- doing so may corrupt
  current parser state and render parser instance useless.
 <p>
  The only reason to call this method (over <code>getText</code>)
  is to avoid construction of a String object (which
  will make a copy of contents).
 */
- (IOSCharArray *)getTextCharacters;

/*!
 @brief Accessor used with <code>getTextCharacters</code>, to know length
  of String stored in returned buffer.
 @return Number of characters within buffer returned
    by <code>getTextCharacters</code> that are part of
    textual content of the current token.
 */
- (jint)getTextLength;

/*!
 @brief Accessor used with <code>getTextCharacters</code>, to know offset
  of the first text content character within buffer.
 @return Offset of the first character within buffer returned
    by <code>getTextCharacters</code> that is part of
    textual content of the current token.
 */
- (jint)getTextOffset;

/*!
 @brief Method that return the <b>starting</b> location of the current
  token; that is, position of the first character from input
  that starts the current token.
 */
- (ComFasterxmlJacksonCoreJsonLocation *)getTokenLocation;

/*!
 @brief Method that can be called to check whether current token
  (one that was just read) has an associated type id, and if
  so, return it.
 Note that while typically caller should check with <code>canReadTypeId</code>
  first, it is not illegal to call this method even if that method returns
  true; but if so, it will return null. This may be used to simplify calling
  code.
 <p>
  Default implementation will simply return null.
 @since 2.3
 */
- (id)getTypeId;

/*!
 @brief Method that will try to convert value of current token to a 
 <b>boolean</b>.
 JSON booleans map naturally; integer numbers other than 0 map to true, and
  0 maps to false
  and Strings 'true' and 'false' map to corresponding values.
 <p>
  If representation can not be converted to a boolean value (including structured types
  like Objects and Arrays),
  default value of <b>false</b> will be returned; no exceptions are thrown.
 */
- (jboolean)getValueAsBoolean;

/*!
 @brief Method that will try to convert value of current token to a 
 <b>boolean</b>.
 JSON booleans map naturally; integer numbers other than 0 map to true, and
  0 maps to false
  and Strings 'true' and 'false' map to corresponding values.
 <p>
  If representation can not be converted to a boolean value (including structured types
  like Objects and Arrays),
  specified <b>def</b> will be returned; no exceptions are thrown.
 */
- (jboolean)getValueAsBooleanWithBoolean:(jboolean)def;

/*!
 @brief Method that will try to convert value of current token to a Java 
 <b>double</b>.
 Numbers are coerced using default Java rules; booleans convert to 0.0 (false)
  and 1.0 (true), and Strings are parsed using default Java language floating
  point parsing rules.
 <p>
  If representation can not be converted to a double (including structured types
  like Objects and Arrays),
  default value of <b>0.0</b> will be returned; no exceptions are thrown.
 */
- (jdouble)getValueAsDouble;

/*!
 @brief Method that will try to convert value of current token to a
  Java <b>double</b>.
 Numbers are coerced using default Java rules; booleans convert to 0.0 (false)
  and 1.0 (true), and Strings are parsed using default Java language floating
  point parsing rules.
 <p>
  If representation can not be converted to a double (including structured types
  like Objects and Arrays),
  specified <b>def</b> will be returned; no exceptions are thrown.
 */
- (jdouble)getValueAsDoubleWithDouble:(jdouble)def;

/*!
 @brief Method that will try to convert value of current token to a 
 <b>int</b>.
 Numbers are coerced using default Java rules; booleans convert to 0 (false)
  and 1 (true), and Strings are parsed using default Java language integer
  parsing rules.
 <p>
  If representation can not be converted to an int (including structured type
  markers like start/end Object/Array)
  default value of <b>0</b> will be returned; no exceptions are thrown.
 */
- (jint)getValueAsInt;

/*!
 @brief Method that will try to convert value of current token to a 
 <b>int</b>.
 Numbers are coerced using default Java rules; booleans convert to 0 (false)
  and 1 (true), and Strings are parsed using default Java language integer
  parsing rules.
 <p>
  If representation can not be converted to an int (including structured type
  markers like start/end Object/Array)
  specified <b>def</b> will be returned; no exceptions are thrown.
 */
- (jint)getValueAsIntWithInt:(jint)def;

/*!
 @brief Method that will try to convert value of current token to a 
 <b>long</b>.
 Numbers are coerced using default Java rules; booleans convert to 0 (false)
  and 1 (true), and Strings are parsed using default Java language integer
  parsing rules.
 <p>
  If representation can not be converted to a long (including structured type
  markers like start/end Object/Array)
  default value of <b>0L</b> will be returned; no exceptions are thrown.
 */
- (jlong)getValueAsLong;

/*!
 @brief Method that will try to convert value of current token to a 
 <b>long</b>.
 Numbers are coerced using default Java rules; booleans convert to 0 (false)
  and 1 (true), and Strings are parsed using default Java language integer
  parsing rules.
 <p>
  If representation can not be converted to a long (including structured type
  markers like start/end Object/Array)
  specified <b>def</b> will be returned; no exceptions are thrown.
 */
- (jlong)getValueAsLongWithLong:(jlong)def;

/*!
 @brief Method that will try to convert value of current token to a 
 <code>java.lang.String</code>.
 JSON Strings map naturally; scalar values get converted to
  their textual representation.
  If representation can not be converted to a String value (including structured types
  like Objects and Arrays and null token), default value of 
 <b>null</b> will be returned; no exceptions are thrown.
 @since 2.1
 */
- (NSString *)getValueAsString;

/*!
 @brief Method that will try to convert value of current token to a 
 <code>java.lang.String</code>.
 JSON Strings map naturally; scalar values get converted to
  their textual representation.
  If representation can not be converted to a String value (including structured types
  like Objects and Arrays and null token), specified default value
  will be returned; no exceptions are thrown.
 @since 2.1
 */
- (NSString *)getValueAsStringWithNSString:(NSString *)def;

/*!
 @brief Method for checking whether parser currently points to
  a token (and data for that token is available).
 Equivalent to check for <code>parser.getCurrentToken() != null</code>.
 @return True if the parser just returned a valid
    token via <code>nextToken</code>; false otherwise (parser
    was just constructed, encountered end-of-input
    and returned null from <code>nextToken</code>, or the token
    has been consumed)
 */
- (jboolean)hasCurrentToken;

/*!
 @brief Method that can be used to determine whether calling of 
 <code>getTextCharacters</code> would be the most efficient
  way to access textual content for the event parser currently
  points to.
 <p> 
  Default implementation simply returns false since only actual
  implementation class has knowledge of its internal buffering
  state.
  Implementations are strongly encouraged to properly override
  this method, to allow efficient copying of content by other
  code.
 @return True if parser currently has character array that can
    be efficiently returned via <code>getTextCharacters</code>; false
    means that it may or may not exist
 */
- (jboolean)hasTextCharacters;

/*!
 @brief Method that is functionally equivalent to:
 <code>
   return currentToken() == t
 </code>
  but may be more efficiently implemented.
 <p>
  Note that no traversal or conversion is performed; so in some
  cases calling method like <code>isExpectedStartArrayToken()</code>
  is necessary instead.
 @since 2.6
 */
- (jboolean)hasTokenWithComFasterxmlJacksonCoreJsonToken:(ComFasterxmlJacksonCoreJsonToken *)t;

/*!
 @brief Method that is functionally equivalent to:
 <code>
   return currentTokenId() == id
 </code>
  but may be more efficiently implemented.
 <p>
  Note that no traversal or conversion is performed; so in some
  cases calling method like <code>isExpectedStartArrayToken()</code>
  is necessary instead.
 @since 2.5
 */
- (jboolean)hasTokenIdWithInt:(jint)id_;

/*!
 @brief Method that can be called to determine whether this parser
  is closed or not.If it is closed, no new tokens can be
  retrieved by calling <code>nextToken</code> (and the underlying
  stream may be closed).
 Closing may be due to an explicit
  call to <code>close</code> or because parser has encountered
  end of input.
 */
- (jboolean)isClosed;

/*!
 @brief Method for checking whether specified <code>Feature</code> is enabled.
 */
- (jboolean)isEnabledWithComFasterxmlJacksonCoreJsonParser_Feature:(ComFasterxmlJacksonCoreJsonParser_Feature *)f;

/*!
 @brief Specialized accessor that can be used to verify that the current
  token indicates start array (usually meaning that current token
  is <code>JsonToken.START_ARRAY</code>) when start array is expected.
 For some specialized parsers this can return true for other cases
  as well; this is usually done to emulate arrays in cases underlying
  format is ambiguous (XML, for example, has no format-level difference
  between Objects and Arrays; it just has elements).
 <p>
  Default implementation is equivalent to:
 @code

    currentToken() == JsonToken.START_ARRAY
 
@endcode
  but may be overridden by custom parser implementations.
 @return True if the current token can be considered as a
    start-array marker (such <code>JsonToken.START_ARRAY</code>);
    false if not.
 */
- (jboolean)isExpectedStartArrayToken;

/*!
 @brief Similar to <code>isExpectedStartArrayToken()</code>, but checks whether stream
  currently points to <code>JsonToken.START_OBJECT</code>.
 @since 2.5
 */
- (jboolean)isExpectedStartObjectToken;

/*!
 @brief Access for checking whether current token is a numeric value token, but
  one that is of "not-a-number" (NaN) variety (including both "NaN" AND
  positive/negative infinity!)
 : not supported by all formats,
  but often supported for <code>JsonToken.VALUE_NUMBER_FLOAT</code>.
 NOTE: roughly equivalent to calling <code>!Double.isFinite()</code>
  on value you would get from calling <code>getDoubleValue()</code>.
 @since 2.9
 */
- (jboolean)isNaN;

/*!
 @brief Method that fetches next token (as if calling <code>nextToken</code>) and
  if it is <code>JsonToken.VALUE_TRUE</code> or <code>JsonToken.VALUE_FALSE</code>
  returns matching Boolean value; otherwise return null.
 It is functionally equivalent to:
 @code

   JsonToken t = nextToken();
   if (t == JsonToken.VALUE_TRUE) return Boolean.TRUE;
   if (t == JsonToken.VALUE_FALSE) return Boolean.FALSE;
   return null;
 
@endcode
  but may be faster for parser to process, and can therefore be used if caller
  expects to get a Boolean value next from input.
 */
- (JavaLangBoolean *)nextBooleanValue;

/*!
 @brief Method that fetches next token (as if calling <code>nextToken</code>) and
  verifies whether it is <code>JsonToken.FIELD_NAME</code>; if it is,
  returns same as <code>getCurrentName()</code>, otherwise null.
 @since 2.5
 */
- (NSString *)nextFieldName;

/*!
 @brief Method that fetches next token (as if calling <code>nextToken</code>) and
  verifies whether it is <code>JsonToken.FIELD_NAME</code> with specified name
  and returns result of that comparison.
 It is functionally equivalent to:
 @code

   return (nextToken() == JsonToken.FIELD_NAME) &amp;&amp; str.getValue().equals(getCurrentName());
 
@endcode
  but may be faster for parser to verify, and can therefore be used if caller
  expects to get such a property name from input next.
 @param str Property name to compare next token to (if next token is    
  <code> JsonToken.FIELD_NAME </code> )
 */
- (jboolean)nextFieldNameWithComFasterxmlJacksonCoreSerializableString:(id<ComFasterxmlJacksonCoreSerializableString>)str;

/*!
 @brief Method that fetches next token (as if calling <code>nextToken</code>) and
  if it is <code>JsonToken.VALUE_NUMBER_INT</code> returns 32-bit int value;
  otherwise returns specified default value
  It is functionally equivalent to:
 @code

   return (nextToken() == JsonToken.VALUE_NUMBER_INT) ?
 getIntValue() : defaultValue;
 
@endcode
  but may be faster for parser to process, and can therefore be used if caller
  expects to get an int value next from input.
 */
- (jint)nextIntValueWithInt:(jint)defaultValue;

/*!
 @brief Method that fetches next token (as if calling <code>nextToken</code>) and
  if it is <code>JsonToken.VALUE_NUMBER_INT</code> returns 64-bit long value;
  otherwise returns specified default value
  It is functionally equivalent to:
 @code

   return (nextToken() == JsonToken.VALUE_NUMBER_INT) ?
 getLongValue() : defaultValue;
 
@endcode
  but may be faster for parser to process, and can therefore be used if caller
  expects to get a long value next from input.
 */
- (jlong)nextLongValueWithLong:(jlong)defaultValue;

/*!
 @brief Method that fetches next token (as if calling <code>nextToken</code>) and
  if it is <code>JsonToken.VALUE_STRING</code> returns contained String value;
  otherwise returns null.
 It is functionally equivalent to:
 @code

   return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;
 
@endcode
  but may be faster for parser to process, and can therefore be used if caller
  expects to get a String value next from input.
 */
- (NSString *)nextTextValue;

/*!
 @brief Main iteration method, which will advance stream enough
  to determine type of the next token, if any.If none
  remaining (stream has no content other than possible
  white space before ending), null will be returned.
 @return Next token from the stream, if any found, or null
    to indicate end-of-input
 */
- (ComFasterxmlJacksonCoreJsonToken *)nextToken;

/*!
 @brief Iteration method that will advance stream enough
  to determine type of the next token that is a value type
  (including JSON Array and Object start/end markers).
 Or put another way, nextToken() will be called once,
  and if <code>JsonToken.FIELD_NAME</code> is returned, another
  time to get the value for the field.
  Method is most useful for iterating over value entries
  of JSON objects; field name will still be available
  by calling <code>getCurrentName</code> when parser points to
  the value.
 @return Next non-field-name token from the stream, if any found,
    or null to indicate end-of-input (or, for non-blocking
    parsers, <code>JsonToken.NOT_AVAILABLE</code> if no tokens were
    available yet)
 */
- (ComFasterxmlJacksonCoreJsonToken *)nextValue;

/*!
 @brief Method that can be used to change what is considered to be
  the current (field) name.
 May be needed to support non-JSON data formats or unusual binding
  conventions; not needed for typical processing.
 <p>
  Note that use of this method should only be done as sort of last
  resort, as it is a work-around for regular operation.
 @param name Name to use as the current name; may be null.
 */
- (void)overrideCurrentNameWithNSString:(NSString *)name;

/*!
 @brief Bulk set method for (re)setting states of <code>FormatFeature</code>s,
  by specifying values (set / clear) along with a mask, to determine
  which features to change, if any.
 <p>
  Default implementation will simply throw an exception to indicate that
  the generator implementation does not support any <code>FormatFeature</code>s.
 @param values Bit mask of set/clear state for features to change
 @param mask Bit mask of features to change
 @since 2.6
 */
- (ComFasterxmlJacksonCoreJsonParser *)overrideFormatFeaturesWithInt:(jint)values
                                                             withInt:(jint)mask;

/*!
 @brief Bulk set method for (re)setting states of features specified by <code>mask</code>.
 Functionally equivalent to
 <code>
     int oldState = getFeatureMask();
     int newState = (oldState &amp; ~mask) | (values &amp; mask);
     setFeatureMask(newState);
 </code>
  but preferred as this lets caller more efficiently specify actual changes made.
 @param values Bit mask of set/clear state for features to change
 @param mask Bit mask of features to change
 @since 2.6
 */
- (ComFasterxmlJacksonCoreJsonParser *)overrideStdFeaturesWithInt:(jint)values
                                                          withInt:(jint)mask;

/*!
 @brief Similar to <code>readBinaryValue(OutputStream)</code> but allows explicitly
  specifying base64 variant to use.
 @param bv base64 variant to use
 @param outArg Output stream to use for passing decoded binary data
 @return Number of bytes that were decoded and written via <code>OutputStream</code>
 @since 2.1
 */
- (jint)readBinaryValueWithComFasterxmlJacksonCoreBase64Variant:(ComFasterxmlJacksonCoreBase64Variant *)bv
                                         withJavaIoOutputStream:(JavaIoOutputStream *)outArg;

/*!
 @brief Method that can be used as an alternative to <code>getBigIntegerValue()</code>,
  especially when value can be large.The main difference (beyond method
  of returning content using <code>OutputStream</code> instead of as byte array)
  is that content will NOT remain accessible after method returns: any content
  processed will be consumed and is not buffered in any way.
 If caller needs
  buffering, it has to implement it.
 @param outArg Output stream to use for passing decoded binary data
 @return Number of bytes that were decoded and written via <code>OutputStream</code>
 @since 2.1
 */
- (jint)readBinaryValueWithJavaIoOutputStream:(JavaIoOutputStream *)outArg;

/*!
 @brief Method to deserialize JSON content into a non-container
  type (it can be an array type, however): typically a bean, array
  or a wrapper type (like <code>java.lang.Boolean</code>).
 <b>Note</b>: method can only be called if the parser has
  an object codec assigned; this is true for parsers constructed
  by <code>MappingJsonFactory</code> (from "jackson-databind" jar)
  but not for <code>JsonFactory</code> (unless its <code>setCodec</code>
  method has been explicitly called).
 <p>
  This method may advance the event stream, for structured types
  the current token will be the closing end marker (END_ARRAY,
  END_OBJECT) of the bound structure. For non-structured Json types
  (and for <code>JsonToken.VALUE_EMBEDDED_OBJECT</code>)
  stream is not advanced.
 <p>
  Note: this method should NOT be used if the result type is a
  container (<code>java.util.Collection</code> or <code>java.util.Map</code>.
  The reason is that due to type erasure, key and value types
  can not be introspected when using this method.
 */
- (id)readValueAsWithIOSClass:(IOSClass *)valueType;

/*!
 @brief Method to deserialize JSON content into a Java type, reference
  to which is passed as argument.Type is passed using so-called
  "super type token"
  and specifically needs to be used if the root type is a 
  parameterized (generic) container type.
 <b>Note</b>: method can only be called if the parser has
  an object codec assigned; this is true for parsers constructed
  by <code>MappingJsonFactory</code> (defined in 'jackson-databind' bundle)
  but not for <code>JsonFactory</code> (unless its <code>setCodec</code>
  method has been explicitly called).
 <p>
  This method may advance the event stream, for structured types
  the current token will be the closing end marker (END_ARRAY,
  END_OBJECT) of the bound structure. For non-structured Json types
  (and for <code>JsonToken.VALUE_EMBEDDED_OBJECT</code>)
  stream is not advanced.
 */
- (id)readValueAsWithComFasterxmlJacksonCoreTypeTypeReference:(ComFasterxmlJacksonCoreTypeTypeReference *)valueTypeRef;

/*!
 @brief Method to deserialize JSON content into equivalent "tree model",
  represented by root <code>TreeNode</code> of resulting model.
 For JSON Arrays it will an array node (with child nodes),
  for objects object node (with child nodes), and for other types
  matching leaf node type. Empty or whitespace documents are null.
 @return root of the document, or null if empty or whitespace.
 */
- (id<ComFasterxmlJacksonCoreTreeNode>)readValueAsTree;

/*!
 @brief Method for reading sequence of Objects from parser stream,
  all with same specified value type.
 */
- (id<JavaUtilIterator>)readValuesAsWithIOSClass:(IOSClass *)valueType;

/*!
 @brief Method for reading sequence of Objects from parser stream,
  all with same specified value type.
 */
- (id<JavaUtilIterator>)readValuesAsWithComFasterxmlJacksonCoreTypeTypeReference:(ComFasterxmlJacksonCoreTypeTypeReference *)valueTypeRef;

/*!
 @brief Method that can be called to push back any content that
  has been read but not consumed by the parser.This is usually
  done after reading all content of interest using parser.
 Content is released by writing it to given stream if possible;
  if underlying input is byte-based it can released, if not (char-based)
  it can not.
 @return -1 if the underlying content source is not byte based
     (that is, input can not be sent to <code>OutputStream</code>;
     otherwise number of bytes released (0 if there was nothing to release)
 @throw IOExceptionif write to stream threw exception
 */
- (jint)releaseBufferedWithJavaIoOutputStream:(JavaIoOutputStream *)outArg;

/*!
 @brief Method that can be called to push back any content that
  has been read but not consumed by the parser.
 This is usually
  done after reading all content of interest using parser.
  Content is released by writing it to given writer if possible;
  if underlying input is char-based it can released, if not (byte-based)
  it can not.
 @return -1 if the underlying content source is not char-based
     (that is, input can not be sent to <code>Writer</code>;
     otherwise number of chars released (0 if there was nothing to release)
 @throw IOExceptionif write using Writer threw exception
 */
- (jint)releaseBufferedWithJavaIoWriter:(JavaIoWriter *)w;

/*!
 @brief Method that can be called to determine if a custom 
 <code>ObjectCodec</code> is needed for binding data parsed
  using <code>JsonParser</code> constructed by this factory
  (which typically also implies the same for serialization
  with <code>JsonGenerator</code>).
 @return True if custom codec is needed with parsers and
    generators created by this factory; false if a general   
 <code>ObjectCodec</code> is enough
 @since 2.1
 */
- (jboolean)requiresCustomCodec;

/*!
 @brief Setter that allows defining <code>ObjectCodec</code> associated with this
  parser, if any.Codec is used by <code>readValueAs(Class)</code>
  method (and its variants).
 */
- (void)setCodecWithComFasterxmlJacksonCoreObjectCodec:(ComFasterxmlJacksonCoreObjectCodec *)c;

/*!
 @brief Helper method, usually equivalent to:
 <code>
    getParsingContext().setCurrentValue(v);
 </code>
 @since 2.5
 */
- (void)setCurrentValueWithId:(id)v;

/*!
 @brief Bulk set method for (re)setting states of all standard <code>Feature</code>s
 @return This parser object, to allow chaining of calls
 @since 2.3
 */
- (ComFasterxmlJacksonCoreJsonParser *)setFeatureMaskWithInt:(jint)mask;

/*!
 @brief Sets the byte[] request payload and the charset
 @since 2.8
 */
- (void)setRequestPayloadOnErrorWithByteArray:(IOSByteArray *)payload
                                 withNSString:(NSString *)charset;

/*!
 @brief Sets the payload to be passed if <code>JsonParseException</code> is thrown.
 @since 2.8
 */
- (void)setRequestPayloadOnErrorWithComFasterxmlJacksonCoreUtilRequestPayload:(ComFasterxmlJacksonCoreUtilRequestPayload *)payload;

/*!
 @brief Sets the String request payload
 @since 2.8
 */
- (void)setRequestPayloadOnErrorWithNSString:(NSString *)payload;

/*!
 @brief Method to call to make this parser use specified schema.Method must
  be called before trying to parse any content, right after parser instance
  has been created.
 Note that not all parsers support schemas; and those that do usually only
  accept specific types of schemas: ones defined for data format parser can read.
 <p>
  If parser does not support specified schema, <code>UnsupportedOperationException</code>
  is thrown.
 @param schema Schema to use
 @throw UnsupportedOperationExceptionif parser does not support schema
 */
- (void)setSchemaWithComFasterxmlJacksonCoreFormatSchema:(id<ComFasterxmlJacksonCoreFormatSchema>)schema;

/*!
 @brief Method that will skip all child tokens of an array or
  object token that the parser currently points to,
  iff stream points to  
 <code>JsonToken.START_OBJECT</code> or <code>JsonToken.START_ARRAY</code>.
 If not, it will do nothing.
  After skipping, stream will point to <b>matching</b>
  <code>JsonToken.END_OBJECT</code> or <code>JsonToken.END_ARRAY</code>
  (possibly skipping nested pairs of START/END OBJECT/ARRAY tokens
  as well as value tokens).
  The idea is that after calling this method, application
  will call <code>nextToken</code> to point to the next
  available token, if any.
 */
- (ComFasterxmlJacksonCoreJsonParser *)skipChildren;

/*!
 @brief Accessor for getting version of the core package, given a parser instance.
 Left for sub-classes to implement.
 */
- (ComFasterxmlJacksonCoreVersion *)version__;

#pragma mark Protected

- (instancetype __nonnull)init;

- (instancetype __nonnull)initWithInt:(jint)features;

- (ComFasterxmlJacksonCoreObjectCodec *)_codec;

/*!
 @brief Helper method for constructing <code>JsonParseException</code>s
  based on current state of the parser
 */
- (ComFasterxmlJacksonCoreJsonParseException *)_constructErrorWithNSString:(NSString *)msg;

/*!
 @brief Helper method to call for operations that are not supported by
  parser implementation.
 @since 2.1
 */
- (void)_reportUnsupportedOperation;

@end

J2OBJC_EMPTY_STATIC_INIT(ComFasterxmlJacksonCoreJsonParser)

J2OBJC_FIELD_SETTER(ComFasterxmlJacksonCoreJsonParser, _requestPayload_, ComFasterxmlJacksonCoreUtilRequestPayload *)

FOUNDATION_EXPORT void ComFasterxmlJacksonCoreJsonParser_init(ComFasterxmlJacksonCoreJsonParser *self);

FOUNDATION_EXPORT void ComFasterxmlJacksonCoreJsonParser_initWithInt_(ComFasterxmlJacksonCoreJsonParser *self, jint features);

J2OBJC_TYPE_LITERAL_HEADER(ComFasterxmlJacksonCoreJsonParser)

#endif

#if !defined (ComFasterxmlJacksonCoreJsonParser_NumberType_) && (INCLUDE_ALL_ComFasterxmlJacksonCoreJsonParser || defined(INCLUDE_ComFasterxmlJacksonCoreJsonParser_NumberType))
#define ComFasterxmlJacksonCoreJsonParser_NumberType_

#define RESTRICT_JavaLangEnum 1
#define INCLUDE_JavaLangEnum 1
#include "java/lang/Enum.h"

@class IOSObjectArray;

typedef NS_ENUM(NSUInteger, ComFasterxmlJacksonCoreJsonParser_NumberType_Enum) {
  ComFasterxmlJacksonCoreJsonParser_NumberType_Enum_INT = 0,
  ComFasterxmlJacksonCoreJsonParser_NumberType_Enum_LONG = 1,
  ComFasterxmlJacksonCoreJsonParser_NumberType_Enum_BIG_INTEGER = 2,
  ComFasterxmlJacksonCoreJsonParser_NumberType_Enum_FLOAT = 3,
  ComFasterxmlJacksonCoreJsonParser_NumberType_Enum_DOUBLE = 4,
  ComFasterxmlJacksonCoreJsonParser_NumberType_Enum_BIG_DECIMAL = 5,
};

/*!
 @brief Enumeration of possible "native" (optimal) types that can be
  used for numbers.
 */
@interface ComFasterxmlJacksonCoreJsonParser_NumberType : JavaLangEnum

#pragma mark Public

+ (ComFasterxmlJacksonCoreJsonParser_NumberType *)valueOfWithNSString:(NSString *)name;

+ (IOSObjectArray *)values;

@end

J2OBJC_STATIC_INIT(ComFasterxmlJacksonCoreJsonParser_NumberType)

/*! INTERNAL ONLY - Use enum accessors declared below. */
FOUNDATION_EXPORT ComFasterxmlJacksonCoreJsonParser_NumberType *ComFasterxmlJacksonCoreJsonParser_NumberType_values_[];

inline ComFasterxmlJacksonCoreJsonParser_NumberType *ComFasterxmlJacksonCoreJsonParser_NumberType_get_INT(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_NumberType, INT)

inline ComFasterxmlJacksonCoreJsonParser_NumberType *ComFasterxmlJacksonCoreJsonParser_NumberType_get_LONG(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_NumberType, LONG)

inline ComFasterxmlJacksonCoreJsonParser_NumberType *ComFasterxmlJacksonCoreJsonParser_NumberType_get_BIG_INTEGER(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_NumberType, BIG_INTEGER)

inline ComFasterxmlJacksonCoreJsonParser_NumberType *ComFasterxmlJacksonCoreJsonParser_NumberType_get_FLOAT(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_NumberType, FLOAT)

inline ComFasterxmlJacksonCoreJsonParser_NumberType *ComFasterxmlJacksonCoreJsonParser_NumberType_get_DOUBLE(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_NumberType, DOUBLE)

inline ComFasterxmlJacksonCoreJsonParser_NumberType *ComFasterxmlJacksonCoreJsonParser_NumberType_get_BIG_DECIMAL(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_NumberType, BIG_DECIMAL)

FOUNDATION_EXPORT IOSObjectArray *ComFasterxmlJacksonCoreJsonParser_NumberType_values(void);

FOUNDATION_EXPORT ComFasterxmlJacksonCoreJsonParser_NumberType *ComFasterxmlJacksonCoreJsonParser_NumberType_valueOfWithNSString_(NSString *name);

FOUNDATION_EXPORT ComFasterxmlJacksonCoreJsonParser_NumberType *ComFasterxmlJacksonCoreJsonParser_NumberType_fromOrdinal(NSUInteger ordinal);

J2OBJC_TYPE_LITERAL_HEADER(ComFasterxmlJacksonCoreJsonParser_NumberType)

#endif

#if !defined (ComFasterxmlJacksonCoreJsonParser_Feature_) && (INCLUDE_ALL_ComFasterxmlJacksonCoreJsonParser || defined(INCLUDE_ComFasterxmlJacksonCoreJsonParser_Feature))
#define ComFasterxmlJacksonCoreJsonParser_Feature_

#define RESTRICT_JavaLangEnum 1
#define INCLUDE_JavaLangEnum 1
#include "java/lang/Enum.h"

@class IOSObjectArray;

typedef NS_ENUM(NSUInteger, ComFasterxmlJacksonCoreJsonParser_Feature_Enum) {
  ComFasterxmlJacksonCoreJsonParser_Feature_Enum_AUTO_CLOSE_SOURCE = 0,
  ComFasterxmlJacksonCoreJsonParser_Feature_Enum_ALLOW_COMMENTS = 1,
  ComFasterxmlJacksonCoreJsonParser_Feature_Enum_ALLOW_YAML_COMMENTS = 2,
  ComFasterxmlJacksonCoreJsonParser_Feature_Enum_ALLOW_UNQUOTED_FIELD_NAMES = 3,
  ComFasterxmlJacksonCoreJsonParser_Feature_Enum_ALLOW_SINGLE_QUOTES = 4,
  ComFasterxmlJacksonCoreJsonParser_Feature_Enum_ALLOW_UNQUOTED_CONTROL_CHARS = 5,
  ComFasterxmlJacksonCoreJsonParser_Feature_Enum_ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER = 6,
  ComFasterxmlJacksonCoreJsonParser_Feature_Enum_ALLOW_NUMERIC_LEADING_ZEROS = 7,
  ComFasterxmlJacksonCoreJsonParser_Feature_Enum_ALLOW_NON_NUMERIC_NUMBERS = 8,
  ComFasterxmlJacksonCoreJsonParser_Feature_Enum_ALLOW_MISSING_VALUES = 9,
  ComFasterxmlJacksonCoreJsonParser_Feature_Enum_ALLOW_TRAILING_COMMA = 10,
  ComFasterxmlJacksonCoreJsonParser_Feature_Enum_STRICT_DUPLICATE_DETECTION = 11,
  ComFasterxmlJacksonCoreJsonParser_Feature_Enum_IGNORE_UNDEFINED = 12,
  ComFasterxmlJacksonCoreJsonParser_Feature_Enum_INCLUDE_SOURCE_IN_LOCATION = 13,
};

/*!
 @brief Enumeration that defines all on/off features for parsers.
 */
@interface ComFasterxmlJacksonCoreJsonParser_Feature : JavaLangEnum

#pragma mark Public

/*!
 @brief Method that calculates bit set (flags) of all features that
  are enabled by default.
 */
+ (jint)collectDefaults;

- (jboolean)enabledByDefault;

/*!
 @since 2.3
 */
- (jboolean)enabledInWithInt:(jint)flags;

- (jint)getMask;

+ (ComFasterxmlJacksonCoreJsonParser_Feature *)valueOfWithNSString:(NSString *)name;

+ (IOSObjectArray *)values;

@end

J2OBJC_STATIC_INIT(ComFasterxmlJacksonCoreJsonParser_Feature)

/*! INTERNAL ONLY - Use enum accessors declared below. */
FOUNDATION_EXPORT ComFasterxmlJacksonCoreJsonParser_Feature *ComFasterxmlJacksonCoreJsonParser_Feature_values_[];

/*!
 @brief Feature that determines whether parser will automatically
  close underlying input source that is NOT owned by the
  parser.If disabled, calling application has to separately
  close the underlying <code>InputStream</code> and <code>Reader</code>
  instances used to create the parser.
 If enabled, parser
  will handle closing, as long as parser itself gets closed:
  this happens when end-of-input is encountered, or parser
  is closed by a call to <code>JsonParser.close</code>.
 <p>
  Feature is enabled by default.
 */
inline ComFasterxmlJacksonCoreJsonParser_Feature *ComFasterxmlJacksonCoreJsonParser_Feature_get_AUTO_CLOSE_SOURCE(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_Feature, AUTO_CLOSE_SOURCE)

/*!
 @brief Feature that determines whether parser will allow use
  of Java/C++ style comments (both '/'+'*' and
  '//' varieties) within parsed content or not.
 <p>
  Since JSON specification does not mention comments as legal
  construct,
  this is a non-standard feature; however, in the wild
  this is extensively used. As such, feature is 
 <b>disabled by default</b> for parsers and must be
  explicitly enabled.
 */
inline ComFasterxmlJacksonCoreJsonParser_Feature *ComFasterxmlJacksonCoreJsonParser_Feature_get_ALLOW_COMMENTS(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_Feature, ALLOW_COMMENTS)

/*!
 @brief Feature that determines whether parser will allow use
  of YAML comments, ones starting with '#' and continuing
  until the end of the line.This commenting style is common
  with scripting languages as well.
 <p>
  Since JSON specification does not mention comments as legal
  construct,
  this is a non-standard feature. As such, feature is 
 <b>disabled by default</b> for parsers and must be
  explicitly enabled.
 */
inline ComFasterxmlJacksonCoreJsonParser_Feature *ComFasterxmlJacksonCoreJsonParser_Feature_get_ALLOW_YAML_COMMENTS(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_Feature, ALLOW_YAML_COMMENTS)

/*!
 @brief Feature that determines whether parser will allow use
  of unquoted field names (which is allowed by Javascript,
  but not by JSON specification).
 <p>
  Since JSON specification requires use of double quotes for
  field names,
  this is a non-standard feature, and as such disabled by default.
 */
inline ComFasterxmlJacksonCoreJsonParser_Feature *ComFasterxmlJacksonCoreJsonParser_Feature_get_ALLOW_UNQUOTED_FIELD_NAMES(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_Feature, ALLOW_UNQUOTED_FIELD_NAMES)

/*!
 @brief Feature that determines whether parser will allow use
  of single quotes (apostrophe, character '\'') for
  quoting Strings (names and String values).If so,
  this is in addition to other acceptable markers.
 but not by JSON specification).
 <p>
  Since JSON specification requires use of double quotes for
  field names,
  this is a non-standard feature, and as such disabled by default.
 */
inline ComFasterxmlJacksonCoreJsonParser_Feature *ComFasterxmlJacksonCoreJsonParser_Feature_get_ALLOW_SINGLE_QUOTES(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_Feature, ALLOW_SINGLE_QUOTES)

/*!
 @brief Feature that determines whether parser will allow
  JSON Strings to contain unquoted control characters
  (ASCII characters with value less than 32, including
  tab and line feed characters) or not.
 If feature is set false, an exception is thrown if such a
  character is encountered.
 <p>
  Since JSON specification requires quoting for all control characters,
  this is a non-standard feature, and as such disabled by default.
 */
inline ComFasterxmlJacksonCoreJsonParser_Feature *ComFasterxmlJacksonCoreJsonParser_Feature_get_ALLOW_UNQUOTED_CONTROL_CHARS(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_Feature, ALLOW_UNQUOTED_CONTROL_CHARS)

/*!
 @brief Feature that can be enabled to accept quoting of all character
  using backslash quoting mechanism: if not enabled, only characters
  that are explicitly listed by JSON specification can be thus
  escaped (see JSON spec for small list of these characters)
 <p>
  Since JSON specification requires quoting for all control characters,
  this is a non-standard feature, and as such disabled by default.
 */
inline ComFasterxmlJacksonCoreJsonParser_Feature *ComFasterxmlJacksonCoreJsonParser_Feature_get_ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_Feature, ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)

/*!
 @brief Feature that determines whether parser will allow
  JSON integral numbers to start with additional (ignorable) 
  zeroes (like: 000001).If enabled, no exception is thrown, and extra
  nulls are silently ignored (and not included in textual representation
  exposed via <code>JsonParser.getText</code>).
 <p>
  Since JSON specification does not allow leading zeroes,
  this is a non-standard feature, and as such disabled by default.
 */
inline ComFasterxmlJacksonCoreJsonParser_Feature *ComFasterxmlJacksonCoreJsonParser_Feature_get_ALLOW_NUMERIC_LEADING_ZEROS(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_Feature, ALLOW_NUMERIC_LEADING_ZEROS)

/*!
 @brief Feature that allows parser to recognize set of
  "Not-a-Number" (NaN) tokens as legal floating number
  values (similar to how many other data formats and
  programming language source code allows it).
 Specific subset contains values that 
 <a href="http://www.w3.org/TR/xmlschema-2/">XML Schema</a>
  (see section 3.2.4.1, Lexical Representation)
  allows (tokens are quoted contents, not including quotes):
 <ul>
   <li>"INF" (for positive infinity), as well as alias of "Infinity"
   <li>"-INF" (for negative infinity), alias "-Infinity"
   <li>"NaN" (for other not-a-numbers, like result of division by zero)
 </ul>
 <p>
  Since JSON specification does not allow use of such values,
  this is a non-standard feature, and as such disabled by default.
 */
inline ComFasterxmlJacksonCoreJsonParser_Feature *ComFasterxmlJacksonCoreJsonParser_Feature_get_ALLOW_NON_NUMERIC_NUMBERS(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_Feature, ALLOW_NON_NUMERIC_NUMBERS)

/*!
 @brief Feature allows the support for "missing" values in a JSON array: missing
  value meaning sequence of two commas, without value in-between but only
  optional white space.
 Enabling this feature will expose "missing" values as <code>JsonToken.VALUE_NULL</code>
  tokens, which typically become Java nulls in arrays and <code>java.util.Collection</code>
  in data-binding. 
 <p>
  For example, enabling this feature will represent a JSON array <code>["value1",,"value3",]</code>
  as <code>["value1", null, "value3", null]</code>  
 <p>
  Since the JSON specification does not allow missing values this is a non-compliant JSON
  feature and is disabled by default.
 @since 2.8
 */
inline ComFasterxmlJacksonCoreJsonParser_Feature *ComFasterxmlJacksonCoreJsonParser_Feature_get_ALLOW_MISSING_VALUES(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_Feature, ALLOW_MISSING_VALUES)

/*!
 @brief Feature that determines whether <code>JsonParser</code> will allow for a single trailing
  comma following the final value (in an Array) or member (in an Object).These commas
  will simply be ignored.
 <p>
  For example, when this feature is enabled, <code>[true,true,]</code> is equivalent to 
 <code>[true, true]</code> and <code>{"a": true,}</code> is equivalent to 
 <code>{"a": true}</code>.
  <p>
  When combined with <code>ALLOW_MISSING_VALUES</code>, this feature takes priority, and
  the final trailing comma in an array declaration does not imply a missing
  (<code>null</code>) value. For example, when both <code>ALLOW_MISSING_VALUES</code>
  and <code>ALLOW_TRAILING_COMMA</code> are enabled, <code>[true,true,]</code> is
  equivalent to <code>[true, true]</code>, and <code>[true,true,,]</code> is equivalent to 
 <code>[true, true, null]</code>.
  <p>
  Since the JSON specification does not permit trailing commas, this is a non-standard
  feature, and as such disabled by default.
 @since 2.9
 */
inline ComFasterxmlJacksonCoreJsonParser_Feature *ComFasterxmlJacksonCoreJsonParser_Feature_get_ALLOW_TRAILING_COMMA(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_Feature, ALLOW_TRAILING_COMMA)

/*!
 @brief Feature that determines whether <code>JsonParser</code> will explicitly
  check that no duplicate JSON Object field names are encountered.
 If enabled, parser will check all names within context and report
  duplicates by throwing a <code>JsonParseException</code>; if disabled,
  parser will not do such checking. Assumption in latter case is
  that caller takes care of handling duplicates at a higher level:
  data-binding, for example, has features to specify detection to
  be done there.
 <p>
  Note that enabling this feature will incur performance overhead
  due to having to store and check additional information: this typically
  adds 20-30% to execution time for basic parsing.
 @since 2.3
 */
inline ComFasterxmlJacksonCoreJsonParser_Feature *ComFasterxmlJacksonCoreJsonParser_Feature_get_STRICT_DUPLICATE_DETECTION(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_Feature, STRICT_DUPLICATE_DETECTION)

/*!
 @brief Feature that determines what to do if the underlying data format requires knowledge
  of all properties to decode (usually via a Schema), and if no definition is
  found for a property that input content contains.
 Typically most textual data formats do NOT require schema information (although
  some do, such as CSV), whereas many binary data formats do require definitions
  (such as Avro, protobuf), although not all (Smile, CBOR, BSON and MessagePack do not).
  Further note that some formats that do require schema information will not be able
  to ignore undefined properties: for example, Avro is fully positional and there is
  no possibility of undefined data. This leaves formats like Protobuf that have identifiers
  that may or may not map; and as such Protobuf format does make use of this feature.
 <p>
  Note that support for this feature is implemented by individual data format
  module, if (and only if) it makes sense for the format in question. For JSON,
  for example, this feature has no effect as properties need not be pre-defined.
 <p>
  Feature is disabled by default, meaning that if the underlying data format
  requires knowledge of all properties to output, attempts to read an unknown
  property will result in a <code>JsonProcessingException</code>
 @since 2.6
 */
inline ComFasterxmlJacksonCoreJsonParser_Feature *ComFasterxmlJacksonCoreJsonParser_Feature_get_IGNORE_UNDEFINED(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_Feature, IGNORE_UNDEFINED)

/*!
 @brief Feature that determines whether <code>JsonLocation</code> instances should be constructed
  with reference to source or not.If source reference is included, its type and contents
  are included when `toString()` method is called (most notably when printing out parse
  exception with that location information).
 If feature is disabled, no source reference
  is passed and source is only indicated as "UNKNOWN".
 <p>
  Most common reason for disabling this feature is to avoid leaking information about
  internal information; this may be done for security reasons.
  Note that even if source reference is included, only parts of contents are usually
  printed, and not the whole contents. Further, many source reference types can not
  necessarily access contents (like streams), so only type is indicated, not contents.
 <p>
  Feature is enabled by default, meaning that "source reference" information is passed
  and some or all of the source content may be included in <code>JsonLocation</code> information
  constructed either when requested explicitly, or when needed for an exception.
 @since 2.9
 */
inline ComFasterxmlJacksonCoreJsonParser_Feature *ComFasterxmlJacksonCoreJsonParser_Feature_get_INCLUDE_SOURCE_IN_LOCATION(void);
J2OBJC_ENUM_CONSTANT(ComFasterxmlJacksonCoreJsonParser_Feature, INCLUDE_SOURCE_IN_LOCATION)

FOUNDATION_EXPORT jint ComFasterxmlJacksonCoreJsonParser_Feature_collectDefaults(void);

FOUNDATION_EXPORT IOSObjectArray *ComFasterxmlJacksonCoreJsonParser_Feature_values(void);

FOUNDATION_EXPORT ComFasterxmlJacksonCoreJsonParser_Feature *ComFasterxmlJacksonCoreJsonParser_Feature_valueOfWithNSString_(NSString *name);

FOUNDATION_EXPORT ComFasterxmlJacksonCoreJsonParser_Feature *ComFasterxmlJacksonCoreJsonParser_Feature_fromOrdinal(NSUInteger ordinal);

J2OBJC_TYPE_LITERAL_HEADER(ComFasterxmlJacksonCoreJsonParser_Feature)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_ComFasterxmlJacksonCoreJsonParser")
