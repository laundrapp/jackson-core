//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/Salton/Documents/Projects/jackson-core/src/main/java/com/fasterxml/jackson/core/Base64Variant.java
//

#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "com/fasterxml/jackson/core/Base64Variant.h"
#include "com/fasterxml/jackson/core/Base64Variants.h"
#include "com/fasterxml/jackson/core/util/ByteArrayBuilder.h"
#include "java/lang/Character.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "java/util/Arrays.h"

@interface ComFasterxmlJacksonCoreBase64Variant () {
 @public
  /*!
   @brief Decoding table used for base 64 decoding.
   */
  IOSIntArray *_asciiToBase64_;
  /*!
   @brief Encoding table used for base 64 decoding when output is done
  as characters.
   */
  IOSCharArray *_base64ToAsciiC_;
  /*!
   @brief Alternative encoding table used for base 64 decoding when output is done
  as ascii bytes.
   */
  IOSByteArray *_base64ToAsciiB_;
  /*!
   @brief Whether this variant uses padding or not.
   */
  jboolean _usesPadding_;
  /*!
   @brief Characted used for padding, if any (<code>PADDING_CHAR_NONE</code> if not).
   */
  jchar _paddingChar_;
  /*!
   @brief Maximum number of encoded base64 characters to output during encoding
  before adding a linefeed, if line length is to be limited
  (<code>java.lang.Integer</code> if not limited).
   <p>
  Note: for some output modes (when writing attributes) linefeeds may
  need to be avoided, and this value ignored.
   */
  jint _maxLineLength_;
}

@end

J2OBJC_FIELD_SETTER(ComFasterxmlJacksonCoreBase64Variant, _asciiToBase64_, IOSIntArray *)
J2OBJC_FIELD_SETTER(ComFasterxmlJacksonCoreBase64Variant, _base64ToAsciiC_, IOSCharArray *)
J2OBJC_FIELD_SETTER(ComFasterxmlJacksonCoreBase64Variant, _base64ToAsciiB_, IOSByteArray *)

inline jint ComFasterxmlJacksonCoreBase64Variant_get_INT_SPACE(void);
#define ComFasterxmlJacksonCoreBase64Variant_INT_SPACE 32
J2OBJC_STATIC_FIELD_CONSTANT(ComFasterxmlJacksonCoreBase64Variant, INT_SPACE, jint)

inline jlong ComFasterxmlJacksonCoreBase64Variant_get_serialVersionUID(void);
#define ComFasterxmlJacksonCoreBase64Variant_serialVersionUID 1LL
J2OBJC_STATIC_FIELD_CONSTANT(ComFasterxmlJacksonCoreBase64Variant, serialVersionUID, jlong)

@implementation ComFasterxmlJacksonCoreBase64Variant

- (instancetype __nonnull)initWithNSString:(NSString *)name
                              withNSString:(NSString *)base64Alphabet
                               withBoolean:(jboolean)usesPadding
                                  withChar:(jchar)paddingChar
                                   withInt:(jint)maxLineLength {
  ComFasterxmlJacksonCoreBase64Variant_initWithNSString_withNSString_withBoolean_withChar_withInt_(self, name, base64Alphabet, usesPadding, paddingChar, maxLineLength);
  return self;
}

- (instancetype __nonnull)initWithComFasterxmlJacksonCoreBase64Variant:(ComFasterxmlJacksonCoreBase64Variant *)base
                                                          withNSString:(NSString *)name
                                                               withInt:(jint)maxLineLength {
  ComFasterxmlJacksonCoreBase64Variant_initWithComFasterxmlJacksonCoreBase64Variant_withNSString_withInt_(self, base, name, maxLineLength);
  return self;
}

- (instancetype __nonnull)initWithComFasterxmlJacksonCoreBase64Variant:(ComFasterxmlJacksonCoreBase64Variant *)base
                                                          withNSString:(NSString *)name
                                                           withBoolean:(jboolean)usesPadding
                                                              withChar:(jchar)paddingChar
                                                               withInt:(jint)maxLineLength {
  ComFasterxmlJacksonCoreBase64Variant_initWithComFasterxmlJacksonCoreBase64Variant_withNSString_withBoolean_withChar_withInt_(self, base, name, usesPadding, paddingChar, maxLineLength);
  return self;
}

- (id)readResolve {
  return ComFasterxmlJacksonCoreBase64Variants_valueOfWithNSString_(_name_);
}

- (NSString *)getName {
  return _name_;
}

- (jboolean)usesPadding {
  return _usesPadding_;
}

- (jboolean)usesPaddingCharWithChar:(jchar)c {
  return c == _paddingChar_;
}

- (jboolean)usesPaddingCharWithInt:(jint)ch {
  return ch == (jint) _paddingChar_;
}

- (jchar)getPaddingChar {
  return _paddingChar_;
}

- (jbyte)getPaddingByte {
  return (jbyte) _paddingChar_;
}

- (jint)getMaxLineLength {
  return _maxLineLength_;
}

- (jint)decodeBase64CharWithChar:(jchar)c {
  jint ch = (jint) c;
  return (ch <= 127) ? IOSIntArray_Get(nil_chk(_asciiToBase64_), ch) : ComFasterxmlJacksonCoreBase64Variant_BASE64_VALUE_INVALID;
}

- (jint)decodeBase64CharWithInt:(jint)ch {
  return (ch <= 127) ? IOSIntArray_Get(nil_chk(_asciiToBase64_), ch) : ComFasterxmlJacksonCoreBase64Variant_BASE64_VALUE_INVALID;
}

- (jint)decodeBase64ByteWithByte:(jbyte)b {
  jint ch = (jint) b;
  if (ch < 0) {
    return ComFasterxmlJacksonCoreBase64Variant_BASE64_VALUE_INVALID;
  }
  return IOSIntArray_Get(nil_chk(_asciiToBase64_), ch);
}

- (jchar)encodeBase64BitsAsCharWithInt:(jint)value {
  return IOSCharArray_Get(nil_chk(_base64ToAsciiC_), value);
}

- (jint)encodeBase64ChunkWithInt:(jint)b24
                   withCharArray:(IOSCharArray *)buffer
                         withInt:(jint)ptr {
  *IOSCharArray_GetRef(nil_chk(buffer), ptr++) = IOSCharArray_Get(nil_chk(_base64ToAsciiC_), (JreRShift32(b24, 18)) & (jint) 0x3F);
  *IOSCharArray_GetRef(buffer, ptr++) = IOSCharArray_Get(_base64ToAsciiC_, (JreRShift32(b24, 12)) & (jint) 0x3F);
  *IOSCharArray_GetRef(buffer, ptr++) = IOSCharArray_Get(_base64ToAsciiC_, (JreRShift32(b24, 6)) & (jint) 0x3F);
  *IOSCharArray_GetRef(buffer, ptr++) = IOSCharArray_Get(_base64ToAsciiC_, b24 & (jint) 0x3F);
  return ptr;
}

- (void)encodeBase64ChunkWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                                           withInt:(jint)b24 {
  [((JavaLangStringBuilder *) nil_chk(sb)) appendWithChar:IOSCharArray_Get(nil_chk(_base64ToAsciiC_), (JreRShift32(b24, 18)) & (jint) 0x3F)];
  [sb appendWithChar:IOSCharArray_Get(_base64ToAsciiC_, (JreRShift32(b24, 12)) & (jint) 0x3F)];
  [sb appendWithChar:IOSCharArray_Get(_base64ToAsciiC_, (JreRShift32(b24, 6)) & (jint) 0x3F)];
  [sb appendWithChar:IOSCharArray_Get(_base64ToAsciiC_, b24 & (jint) 0x3F)];
}

- (jint)encodeBase64PartialWithInt:(jint)bits
                           withInt:(jint)outputBytes
                     withCharArray:(IOSCharArray *)buffer
                           withInt:(jint)outPtr {
  *IOSCharArray_GetRef(nil_chk(buffer), outPtr++) = IOSCharArray_Get(nil_chk(_base64ToAsciiC_), (JreRShift32(bits, 18)) & (jint) 0x3F);
  *IOSCharArray_GetRef(buffer, outPtr++) = IOSCharArray_Get(_base64ToAsciiC_, (JreRShift32(bits, 12)) & (jint) 0x3F);
  if (_usesPadding_) {
    *IOSCharArray_GetRef(buffer, outPtr++) = (outputBytes == 2) ? IOSCharArray_Get(_base64ToAsciiC_, (JreRShift32(bits, 6)) & (jint) 0x3F) : _paddingChar_;
    *IOSCharArray_GetRef(buffer, outPtr++) = _paddingChar_;
  }
  else {
    if (outputBytes == 2) {
      *IOSCharArray_GetRef(buffer, outPtr++) = IOSCharArray_Get(_base64ToAsciiC_, (JreRShift32(bits, 6)) & (jint) 0x3F);
    }
  }
  return outPtr;
}

- (void)encodeBase64PartialWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                                             withInt:(jint)bits
                                             withInt:(jint)outputBytes {
  [((JavaLangStringBuilder *) nil_chk(sb)) appendWithChar:IOSCharArray_Get(nil_chk(_base64ToAsciiC_), (JreRShift32(bits, 18)) & (jint) 0x3F)];
  [sb appendWithChar:IOSCharArray_Get(_base64ToAsciiC_, (JreRShift32(bits, 12)) & (jint) 0x3F)];
  if (_usesPadding_) {
    [sb appendWithChar:(outputBytes == 2) ? IOSCharArray_Get(_base64ToAsciiC_, (JreRShift32(bits, 6)) & (jint) 0x3F) : _paddingChar_];
    [sb appendWithChar:_paddingChar_];
  }
  else {
    if (outputBytes == 2) {
      [sb appendWithChar:IOSCharArray_Get(_base64ToAsciiC_, (JreRShift32(bits, 6)) & (jint) 0x3F)];
    }
  }
}

- (jbyte)encodeBase64BitsAsByteWithInt:(jint)value {
  return IOSByteArray_Get(nil_chk(_base64ToAsciiB_), value);
}

- (jint)encodeBase64ChunkWithInt:(jint)b24
                   withByteArray:(IOSByteArray *)buffer
                         withInt:(jint)ptr {
  *IOSByteArray_GetRef(nil_chk(buffer), ptr++) = IOSByteArray_Get(nil_chk(_base64ToAsciiB_), (JreRShift32(b24, 18)) & (jint) 0x3F);
  *IOSByteArray_GetRef(buffer, ptr++) = IOSByteArray_Get(_base64ToAsciiB_, (JreRShift32(b24, 12)) & (jint) 0x3F);
  *IOSByteArray_GetRef(buffer, ptr++) = IOSByteArray_Get(_base64ToAsciiB_, (JreRShift32(b24, 6)) & (jint) 0x3F);
  *IOSByteArray_GetRef(buffer, ptr++) = IOSByteArray_Get(_base64ToAsciiB_, b24 & (jint) 0x3F);
  return ptr;
}

- (jint)encodeBase64PartialWithInt:(jint)bits
                           withInt:(jint)outputBytes
                     withByteArray:(IOSByteArray *)buffer
                           withInt:(jint)outPtr {
  *IOSByteArray_GetRef(nil_chk(buffer), outPtr++) = IOSByteArray_Get(nil_chk(_base64ToAsciiB_), (JreRShift32(bits, 18)) & (jint) 0x3F);
  *IOSByteArray_GetRef(buffer, outPtr++) = IOSByteArray_Get(_base64ToAsciiB_, (JreRShift32(bits, 12)) & (jint) 0x3F);
  if (_usesPadding_) {
    jbyte pb = (jbyte) _paddingChar_;
    *IOSByteArray_GetRef(buffer, outPtr++) = (outputBytes == 2) ? IOSByteArray_Get(_base64ToAsciiB_, (JreRShift32(bits, 6)) & (jint) 0x3F) : pb;
    *IOSByteArray_GetRef(buffer, outPtr++) = pb;
  }
  else {
    if (outputBytes == 2) {
      *IOSByteArray_GetRef(buffer, outPtr++) = IOSByteArray_Get(_base64ToAsciiB_, (JreRShift32(bits, 6)) & (jint) 0x3F);
    }
  }
  return outPtr;
}

- (NSString *)encodeWithByteArray:(IOSByteArray *)input {
  return [self encodeWithByteArray:input withBoolean:false];
}

- (NSString *)encodeWithByteArray:(IOSByteArray *)input
                      withBoolean:(jboolean)addQuotes {
  jint inputEnd = ((IOSByteArray *) nil_chk(input))->size_;
  JavaLangStringBuilder *sb;
  {
    jint outputLen = inputEnd + (JreRShift32(inputEnd, 2)) + (JreRShift32(inputEnd, 3));
    sb = create_JavaLangStringBuilder_initWithInt_(outputLen);
  }
  if (addQuotes) {
    [sb appendWithChar:'"'];
  }
  jint chunksBeforeLF = JreRShift32([self getMaxLineLength], 2);
  jint inputPtr = 0;
  jint safeInputEnd = inputEnd - 3;
  while (inputPtr <= safeInputEnd) {
    jint b24 = JreLShift32(((jint) IOSByteArray_Get(input, inputPtr++)), 8);
    b24 |= ((jint) IOSByteArray_Get(input, inputPtr++)) & (jint) 0xFF;
    b24 = (JreLShift32(b24, 8)) | (((jint) IOSByteArray_Get(input, inputPtr++)) & (jint) 0xFF);
    [self encodeBase64ChunkWithJavaLangStringBuilder:sb withInt:b24];
    if (--chunksBeforeLF <= 0) {
      [sb appendWithChar:'\\'];
      [sb appendWithChar:'n'];
      chunksBeforeLF = JreRShift32([self getMaxLineLength], 2);
    }
  }
  jint inputLeft = inputEnd - inputPtr;
  if (inputLeft > 0) {
    jint b24 = JreLShift32(((jint) IOSByteArray_Get(input, inputPtr++)), 16);
    if (inputLeft == 2) {
      b24 |= JreLShift32((((jint) IOSByteArray_Get(input, inputPtr++)) & (jint) 0xFF), 8);
    }
    [self encodeBase64PartialWithJavaLangStringBuilder:sb withInt:b24 withInt:inputLeft];
  }
  if (addQuotes) {
    [sb appendWithChar:'"'];
  }
  return [sb description];
}

- (IOSByteArray *)decodeWithNSString:(NSString *)input {
  ComFasterxmlJacksonCoreUtilByteArrayBuilder *b = create_ComFasterxmlJacksonCoreUtilByteArrayBuilder_init();
  [self decodeWithNSString:input withComFasterxmlJacksonCoreUtilByteArrayBuilder:b];
  return [b toByteArray];
}

- (void)decodeWithNSString:(NSString *)str
withComFasterxmlJacksonCoreUtilByteArrayBuilder:(ComFasterxmlJacksonCoreUtilByteArrayBuilder *)builder {
  jint ptr = 0;
  jint len = [((NSString *) nil_chk(str)) java_length];
  while (ptr < len) {
    jchar ch;
    do {
      ch = [str charAtWithInt:ptr++];
    }
    while ((ptr < len) && (ch <= ComFasterxmlJacksonCoreBase64Variant_INT_SPACE));
    jint bits = [self decodeBase64CharWithChar:ch];
    if (bits < 0) {
      [self _reportInvalidBase64WithChar:ch withInt:0 withNSString:nil];
    }
    jint decodedData = bits;
    if (ptr >= len) {
      [self _reportBase64EOF];
    }
    ch = [str charAtWithInt:ptr++];
    bits = [self decodeBase64CharWithChar:ch];
    if (bits < 0) {
      [self _reportInvalidBase64WithChar:ch withInt:1 withNSString:nil];
    }
    decodedData = (JreLShift32(decodedData, 6)) | bits;
    if (ptr >= len) {
      if (![self usesPadding]) {
        JreRShiftAssignInt(&decodedData, 4);
        [((ComFasterxmlJacksonCoreUtilByteArrayBuilder *) nil_chk(builder)) appendWithInt:decodedData];
        break;
      }
      [self _reportBase64EOF];
    }
    ch = [str charAtWithInt:ptr++];
    bits = [self decodeBase64CharWithChar:ch];
    if (bits < 0) {
      if (bits != ComFasterxmlJacksonCoreBase64Variant_BASE64_VALUE_PADDING) {
        [self _reportInvalidBase64WithChar:ch withInt:2 withNSString:nil];
      }
      if (ptr >= len) {
        [self _reportBase64EOF];
      }
      ch = [str charAtWithInt:ptr++];
      if (![self usesPaddingCharWithChar:ch]) {
        [self _reportInvalidBase64WithChar:ch withInt:3 withNSString:JreStrcat("$CC", @"expected padding character '", [self getPaddingChar], '\'')];
      }
      JreRShiftAssignInt(&decodedData, 4);
      [((ComFasterxmlJacksonCoreUtilByteArrayBuilder *) nil_chk(builder)) appendWithInt:decodedData];
      continue;
    }
    decodedData = (JreLShift32(decodedData, 6)) | bits;
    if (ptr >= len) {
      if (![self usesPadding]) {
        JreRShiftAssignInt(&decodedData, 2);
        [((ComFasterxmlJacksonCoreUtilByteArrayBuilder *) nil_chk(builder)) appendTwoBytesWithInt:decodedData];
        break;
      }
      [self _reportBase64EOF];
    }
    ch = [str charAtWithInt:ptr++];
    bits = [self decodeBase64CharWithChar:ch];
    if (bits < 0) {
      if (bits != ComFasterxmlJacksonCoreBase64Variant_BASE64_VALUE_PADDING) {
        [self _reportInvalidBase64WithChar:ch withInt:3 withNSString:nil];
      }
      JreRShiftAssignInt(&decodedData, 2);
      [((ComFasterxmlJacksonCoreUtilByteArrayBuilder *) nil_chk(builder)) appendTwoBytesWithInt:decodedData];
    }
    else {
      decodedData = (JreLShift32(decodedData, 6)) | bits;
      [((ComFasterxmlJacksonCoreUtilByteArrayBuilder *) nil_chk(builder)) appendThreeBytesWithInt:decodedData];
    }
  }
}

- (NSString *)description {
  return _name_;
}

- (jboolean)isEqual:(id)o {
  return o == self;
}

- (NSUInteger)hash {
  return ((jint) [((NSString *) nil_chk(_name_)) hash]);
}

- (void)_reportInvalidBase64WithChar:(jchar)ch
                             withInt:(jint)bindex
                        withNSString:(NSString *)msg {
  NSString *base;
  if (ch <= ComFasterxmlJacksonCoreBase64Variant_INT_SPACE) {
    base = JreStrcat("$$$I$", @"Illegal white space character (code 0x", JavaLangInteger_toHexStringWithInt_(ch), @") as character #", (bindex + 1), @" of 4-char base64 unit: can only used between units");
  }
  else if ([self usesPaddingCharWithChar:ch]) {
    base = JreStrcat("$C$I$", @"Unexpected padding character ('", [self getPaddingChar], @"') as character #", (bindex + 1), @" of 4-char base64 unit: padding only legal as 3rd or 4th character");
  }
  else if (!JavaLangCharacter_isDefinedWithChar_(ch) || JavaLangCharacter_isISOControlWithChar_(ch)) {
    base = JreStrcat("$$$", @"Illegal character (code 0x", JavaLangInteger_toHexStringWithInt_(ch), @") in base64 content");
  }
  else {
    base = JreStrcat("$C$$$", @"Illegal character '", ch, @"' (code 0x", JavaLangInteger_toHexStringWithInt_(ch), @") in base64 content");
  }
  if (msg != nil) {
    base = JreStrcat("$$$", base, @": ", msg);
  }
  @throw create_JavaLangIllegalArgumentException_initWithNSString_(base);
}

- (void)_reportBase64EOF {
  @throw create_JavaLangIllegalArgumentException_initWithNSString_(@"Unexpected end-of-String in base64 content");
}

- (void)dealloc {
  RELEASE_(_asciiToBase64_);
  RELEASE_(_base64ToAsciiC_);
  RELEASE_(_base64ToAsciiB_);
  RELEASE_(_name_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { NULL, NULL, 0x1, -1, 0, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 1, -1, -1, -1, -1 },
    { NULL, NULL, 0x1, -1, 2, -1, -1, -1, -1 },
    { NULL, "LNSObject;", 0x4, -1, -1, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 3, 4, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 3, 5, -1, -1, -1, -1 },
    { NULL, "C", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "B", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, -1, -1, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 6, 4, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 6, 5, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 7, 8, -1, -1, -1, -1 },
    { NULL, "C", 0x1, 9, 5, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 10, 11, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 10, 12, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 13, 14, -1, -1, -1, -1 },
    { NULL, "V", 0x1, 13, 15, -1, -1, -1, -1 },
    { NULL, "B", 0x1, 16, 5, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 10, 17, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 13, 18, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 19, 20, -1, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 19, 21, -1, -1, -1, -1 },
    { NULL, "[B", 0x1, 22, 23, 24, -1, -1, -1 },
    { NULL, "V", 0x1, 22, 25, 24, -1, -1, -1 },
    { NULL, "LNSString;", 0x1, 26, -1, -1, -1, -1, -1 },
    { NULL, "Z", 0x1, 27, 28, -1, -1, -1, -1 },
    { NULL, "I", 0x1, 29, -1, -1, -1, -1, -1 },
    { NULL, "V", 0x4, 30, 31, 24, -1, -1, -1 },
    { NULL, "V", 0x4, -1, -1, 24, -1, -1, -1 },
  };
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wobjc-multiple-method-names"
  #pragma clang diagnostic ignored "-Wundeclared-selector"
  methods[0].selector = @selector(initWithNSString:withNSString:withBoolean:withChar:withInt:);
  methods[1].selector = @selector(initWithComFasterxmlJacksonCoreBase64Variant:withNSString:withInt:);
  methods[2].selector = @selector(initWithComFasterxmlJacksonCoreBase64Variant:withNSString:withBoolean:withChar:withInt:);
  methods[3].selector = @selector(readResolve);
  methods[4].selector = @selector(getName);
  methods[5].selector = @selector(usesPadding);
  methods[6].selector = @selector(usesPaddingCharWithChar:);
  methods[7].selector = @selector(usesPaddingCharWithInt:);
  methods[8].selector = @selector(getPaddingChar);
  methods[9].selector = @selector(getPaddingByte);
  methods[10].selector = @selector(getMaxLineLength);
  methods[11].selector = @selector(decodeBase64CharWithChar:);
  methods[12].selector = @selector(decodeBase64CharWithInt:);
  methods[13].selector = @selector(decodeBase64ByteWithByte:);
  methods[14].selector = @selector(encodeBase64BitsAsCharWithInt:);
  methods[15].selector = @selector(encodeBase64ChunkWithInt:withCharArray:withInt:);
  methods[16].selector = @selector(encodeBase64ChunkWithJavaLangStringBuilder:withInt:);
  methods[17].selector = @selector(encodeBase64PartialWithInt:withInt:withCharArray:withInt:);
  methods[18].selector = @selector(encodeBase64PartialWithJavaLangStringBuilder:withInt:withInt:);
  methods[19].selector = @selector(encodeBase64BitsAsByteWithInt:);
  methods[20].selector = @selector(encodeBase64ChunkWithInt:withByteArray:withInt:);
  methods[21].selector = @selector(encodeBase64PartialWithInt:withInt:withByteArray:withInt:);
  methods[22].selector = @selector(encodeWithByteArray:);
  methods[23].selector = @selector(encodeWithByteArray:withBoolean:);
  methods[24].selector = @selector(decodeWithNSString:);
  methods[25].selector = @selector(decodeWithNSString:withComFasterxmlJacksonCoreUtilByteArrayBuilder:);
  methods[26].selector = @selector(description);
  methods[27].selector = @selector(isEqual:);
  methods[28].selector = @selector(hash);
  methods[29].selector = @selector(_reportInvalidBase64WithChar:withInt:withNSString:);
  methods[30].selector = @selector(_reportBase64EOF);
  #pragma clang diagnostic pop
  static const J2ObjcFieldInfo fields[] = {
    { "INT_SPACE", "I", .constantValue.asInt = ComFasterxmlJacksonCoreBase64Variant_INT_SPACE, 0x1a, -1, -1, -1, -1 },
    { "serialVersionUID", "J", .constantValue.asLong = ComFasterxmlJacksonCoreBase64Variant_serialVersionUID, 0x1a, -1, -1, -1, -1 },
    { "PADDING_CHAR_NONE", "C", .constantValue.asUnichar = ComFasterxmlJacksonCoreBase64Variant_PADDING_CHAR_NONE, 0x18, -1, -1, -1, -1 },
    { "BASE64_VALUE_INVALID", "I", .constantValue.asInt = ComFasterxmlJacksonCoreBase64Variant_BASE64_VALUE_INVALID, 0x19, -1, -1, -1, -1 },
    { "BASE64_VALUE_PADDING", "I", .constantValue.asInt = ComFasterxmlJacksonCoreBase64Variant_BASE64_VALUE_PADDING, 0x19, -1, -1, -1, -1 },
    { "_asciiToBase64_", "[I", .constantValue.asLong = 0, 0x92, -1, -1, -1, -1 },
    { "_base64ToAsciiC_", "[C", .constantValue.asLong = 0, 0x92, -1, -1, -1, -1 },
    { "_base64ToAsciiB_", "[B", .constantValue.asLong = 0, 0x92, -1, -1, -1, -1 },
    { "_name_", "LNSString;", .constantValue.asLong = 0, 0x10, -1, -1, -1, -1 },
    { "_usesPadding_", "Z", .constantValue.asLong = 0, 0x92, -1, -1, -1, -1 },
    { "_paddingChar_", "C", .constantValue.asLong = 0, 0x92, -1, -1, -1, -1 },
    { "_maxLineLength_", "I", .constantValue.asLong = 0, 0x92, -1, -1, -1, -1 },
  };
  static const void *ptrTable[] = { "LNSString;LNSString;ZCI", "LComFasterxmlJacksonCoreBase64Variant;LNSString;I", "LComFasterxmlJacksonCoreBase64Variant;LNSString;ZCI", "usesPaddingChar", "C", "I", "decodeBase64Char", "decodeBase64Byte", "B", "encodeBase64BitsAsChar", "encodeBase64Chunk", "I[CI", "LJavaLangStringBuilder;I", "encodeBase64Partial", "II[CI", "LJavaLangStringBuilder;II", "encodeBase64BitsAsByte", "I[BI", "II[BI", "encode", "[B", "[BZ", "decode", "LNSString;", "LJavaLangIllegalArgumentException;", "LNSString;LComFasterxmlJacksonCoreUtilByteArrayBuilder;", "toString", "equals", "LNSObject;", "hashCode", "_reportInvalidBase64", "CILNSString;" };
  static const J2ObjcClassInfo _ComFasterxmlJacksonCoreBase64Variant = { "Base64Variant", "com.fasterxml.jackson.core", ptrTable, methods, fields, 7, 0x11, 31, 12, -1, -1, -1, -1, -1 };
  return &_ComFasterxmlJacksonCoreBase64Variant;
}

@end

void ComFasterxmlJacksonCoreBase64Variant_initWithNSString_withNSString_withBoolean_withChar_withInt_(ComFasterxmlJacksonCoreBase64Variant *self, NSString *name, NSString *base64Alphabet, jboolean usesPadding, jchar paddingChar, jint maxLineLength) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->_asciiToBase64_, [IOSIntArray newArrayWithLength:128]);
  JreStrongAssignAndConsume(&self->_base64ToAsciiC_, [IOSCharArray newArrayWithLength:64]);
  JreStrongAssignAndConsume(&self->_base64ToAsciiB_, [IOSByteArray newArrayWithLength:64]);
  JreStrongAssign(&self->_name_, name);
  self->_usesPadding_ = usesPadding;
  self->_paddingChar_ = paddingChar;
  self->_maxLineLength_ = maxLineLength;
  jint alphaLen = [((NSString *) nil_chk(base64Alphabet)) java_length];
  if (alphaLen != 64) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$IC", @"Base64Alphabet length must be exactly 64 (was ", alphaLen, ')'));
  }
  [base64Alphabet java_getChars:0 sourceEnd:alphaLen destination:self->_base64ToAsciiC_ destinationBegin:0];
  JavaUtilArrays_fillWithIntArray_withInt_(self->_asciiToBase64_, ComFasterxmlJacksonCoreBase64Variant_BASE64_VALUE_INVALID);
  for (jint i = 0; i < alphaLen; ++i) {
    jchar alpha = IOSCharArray_Get(self->_base64ToAsciiC_, i);
    *IOSByteArray_GetRef(self->_base64ToAsciiB_, i) = (jbyte) alpha;
    *IOSIntArray_GetRef(self->_asciiToBase64_, alpha) = i;
  }
  if (usesPadding) {
    *IOSIntArray_GetRef(self->_asciiToBase64_, (jint) paddingChar) = ComFasterxmlJacksonCoreBase64Variant_BASE64_VALUE_PADDING;
  }
}

ComFasterxmlJacksonCoreBase64Variant *new_ComFasterxmlJacksonCoreBase64Variant_initWithNSString_withNSString_withBoolean_withChar_withInt_(NSString *name, NSString *base64Alphabet, jboolean usesPadding, jchar paddingChar, jint maxLineLength) {
  J2OBJC_NEW_IMPL(ComFasterxmlJacksonCoreBase64Variant, initWithNSString_withNSString_withBoolean_withChar_withInt_, name, base64Alphabet, usesPadding, paddingChar, maxLineLength)
}

ComFasterxmlJacksonCoreBase64Variant *create_ComFasterxmlJacksonCoreBase64Variant_initWithNSString_withNSString_withBoolean_withChar_withInt_(NSString *name, NSString *base64Alphabet, jboolean usesPadding, jchar paddingChar, jint maxLineLength) {
  J2OBJC_CREATE_IMPL(ComFasterxmlJacksonCoreBase64Variant, initWithNSString_withNSString_withBoolean_withChar_withInt_, name, base64Alphabet, usesPadding, paddingChar, maxLineLength)
}

void ComFasterxmlJacksonCoreBase64Variant_initWithComFasterxmlJacksonCoreBase64Variant_withNSString_withInt_(ComFasterxmlJacksonCoreBase64Variant *self, ComFasterxmlJacksonCoreBase64Variant *base, NSString *name, jint maxLineLength) {
  ComFasterxmlJacksonCoreBase64Variant_initWithComFasterxmlJacksonCoreBase64Variant_withNSString_withBoolean_withChar_withInt_(self, base, name, ((ComFasterxmlJacksonCoreBase64Variant *) nil_chk(base))->_usesPadding_, base->_paddingChar_, maxLineLength);
}

ComFasterxmlJacksonCoreBase64Variant *new_ComFasterxmlJacksonCoreBase64Variant_initWithComFasterxmlJacksonCoreBase64Variant_withNSString_withInt_(ComFasterxmlJacksonCoreBase64Variant *base, NSString *name, jint maxLineLength) {
  J2OBJC_NEW_IMPL(ComFasterxmlJacksonCoreBase64Variant, initWithComFasterxmlJacksonCoreBase64Variant_withNSString_withInt_, base, name, maxLineLength)
}

ComFasterxmlJacksonCoreBase64Variant *create_ComFasterxmlJacksonCoreBase64Variant_initWithComFasterxmlJacksonCoreBase64Variant_withNSString_withInt_(ComFasterxmlJacksonCoreBase64Variant *base, NSString *name, jint maxLineLength) {
  J2OBJC_CREATE_IMPL(ComFasterxmlJacksonCoreBase64Variant, initWithComFasterxmlJacksonCoreBase64Variant_withNSString_withInt_, base, name, maxLineLength)
}

void ComFasterxmlJacksonCoreBase64Variant_initWithComFasterxmlJacksonCoreBase64Variant_withNSString_withBoolean_withChar_withInt_(ComFasterxmlJacksonCoreBase64Variant *self, ComFasterxmlJacksonCoreBase64Variant *base, NSString *name, jboolean usesPadding, jchar paddingChar, jint maxLineLength) {
  NSObject_init(self);
  JreStrongAssignAndConsume(&self->_asciiToBase64_, [IOSIntArray newArrayWithLength:128]);
  JreStrongAssignAndConsume(&self->_base64ToAsciiC_, [IOSCharArray newArrayWithLength:64]);
  JreStrongAssignAndConsume(&self->_base64ToAsciiB_, [IOSByteArray newArrayWithLength:64]);
  JreStrongAssign(&self->_name_, name);
  IOSByteArray *srcB = ((ComFasterxmlJacksonCoreBase64Variant *) nil_chk(base))->_base64ToAsciiB_;
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(srcB, 0, self->_base64ToAsciiB_, 0, srcB->size_);
  IOSCharArray *srcC = base->_base64ToAsciiC_;
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(srcC, 0, self->_base64ToAsciiC_, 0, srcC->size_);
  IOSIntArray *srcV = base->_asciiToBase64_;
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(srcV, 0, self->_asciiToBase64_, 0, srcV->size_);
  self->_usesPadding_ = usesPadding;
  self->_paddingChar_ = paddingChar;
  self->_maxLineLength_ = maxLineLength;
}

ComFasterxmlJacksonCoreBase64Variant *new_ComFasterxmlJacksonCoreBase64Variant_initWithComFasterxmlJacksonCoreBase64Variant_withNSString_withBoolean_withChar_withInt_(ComFasterxmlJacksonCoreBase64Variant *base, NSString *name, jboolean usesPadding, jchar paddingChar, jint maxLineLength) {
  J2OBJC_NEW_IMPL(ComFasterxmlJacksonCoreBase64Variant, initWithComFasterxmlJacksonCoreBase64Variant_withNSString_withBoolean_withChar_withInt_, base, name, usesPadding, paddingChar, maxLineLength)
}

ComFasterxmlJacksonCoreBase64Variant *create_ComFasterxmlJacksonCoreBase64Variant_initWithComFasterxmlJacksonCoreBase64Variant_withNSString_withBoolean_withChar_withInt_(ComFasterxmlJacksonCoreBase64Variant *base, NSString *name, jboolean usesPadding, jchar paddingChar, jint maxLineLength) {
  J2OBJC_CREATE_IMPL(ComFasterxmlJacksonCoreBase64Variant, initWithComFasterxmlJacksonCoreBase64Variant_withNSString_withBoolean_withChar_withInt_, base, name, usesPadding, paddingChar, maxLineLength)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ComFasterxmlJacksonCoreBase64Variant)
